"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/meyda";
exports.ids = ["vendor-chunks/meyda"];
exports.modules = {

/***/ "(ssr)/./node_modules/meyda/dist/node/main.js":
/*!**********************************************!*\
  !*** ./node_modules/meyda/dist/node/main.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nfunction blackman(size) {\n    var blackmanBuffer = new Float32Array(size);\n    var coeff1 = (2 * Math.PI) / (size - 1);\n    var coeff2 = 2 * coeff1;\n    //According to http://uk.mathworks.com/help/signal/ref/blackman.html\n    //first half of the window\n    for (var i = 0; i < size / 2; i++) {\n        blackmanBuffer[i] =\n            0.42 - 0.5 * Math.cos(i * coeff1) + 0.08 * Math.cos(i * coeff2);\n    }\n    //second half of the window\n    for (var i = Math.ceil(size / 2); i > 0; i--) {\n        blackmanBuffer[size - i] = blackmanBuffer[i - 1];\n    }\n    return blackmanBuffer;\n}\nfunction sine(size) {\n    var coeff = Math.PI / (size - 1);\n    var sineBuffer = new Float32Array(size);\n    for (var i = 0; i < size; i++) {\n        sineBuffer[i] = Math.sin(coeff * i);\n    }\n    return sineBuffer;\n}\nfunction hanning(size) {\n    var hanningBuffer = new Float32Array(size);\n    for (var i = 0; i < size; i++) {\n        // According to the R documentation\n        // http://ugrad.stat.ubc.ca/R/library/e1071/html/hanning.window.html\n        hanningBuffer[i] = 0.5 - 0.5 * Math.cos((2 * Math.PI * i) / (size - 1));\n    }\n    return hanningBuffer;\n}\nfunction hamming(size) {\n    var hammingBuffer = new Float32Array(size);\n    for (var i = 0; i < size; i++) {\n        //According to http://uk.mathworks.com/help/signal/ref/hamming.html\n        hammingBuffer[i] = 0.54 - 0.46 * Math.cos(2 * Math.PI * (i / size - 1));\n    }\n    return hammingBuffer;\n}\n\nvar windowing = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    blackman: blackman,\n    hamming: hamming,\n    hanning: hanning,\n    sine: sine\n});\n\nvar windows = {};\nfunction isPowerOfTwo(num) {\n    while (num % 2 === 0 && num > 1) {\n        num /= 2;\n    }\n    return num === 1;\n}\nfunction pointwiseBufferMult(a, b) {\n    var c = [];\n    for (var i = 0; i < Math.min(a.length, b.length); i++) {\n        c[i] = a[i] * b[i];\n    }\n    return c;\n}\nfunction applyWindow(signal, windowname) {\n    if (windowname !== \"rect\") {\n        if (windowname === \"\" || !windowname)\n            windowname = \"hanning\";\n        if (!windows[windowname])\n            windows[windowname] = {};\n        if (!windows[windowname][signal.length]) {\n            try {\n                windows[windowname][signal.length] = windowing[windowname](signal.length);\n            }\n            catch (e) {\n                throw new Error(\"Invalid windowing function\");\n            }\n        }\n        signal = pointwiseBufferMult(signal, windows[windowname][signal.length]);\n    }\n    return signal;\n}\nfunction createBarkScale(length, sampleRate, bufferSize) {\n    var barkScale = new Float32Array(length);\n    for (var i = 0; i < barkScale.length; i++) {\n        barkScale[i] = (i * sampleRate) / bufferSize;\n        barkScale[i] =\n            13 * Math.atan(barkScale[i] / 1315.8) +\n                3.5 * Math.atan(Math.pow(barkScale[i] / 7518, 2));\n    }\n    return barkScale;\n}\nfunction arrayToTyped(t) {\n    // utility to convert arrays to typed F32 arrays\n    return Float32Array.from(t);\n}\nfunction _melToFreq(melValue) {\n    var freqValue = 700 * (Math.exp(melValue / 1125) - 1);\n    return freqValue;\n}\nfunction _freqToMel(freqValue) {\n    var melValue = 1125 * Math.log(1 + freqValue / 700);\n    return melValue;\n}\nfunction createMelFilterBank(numFilters, sampleRate, bufferSize) {\n    //the +2 is the upper and lower limits\n    var melValues = new Float32Array(numFilters + 2);\n    var melValuesInFreq = new Float32Array(numFilters + 2);\n    //Generate limits in Hz - from 0 to the nyquist.\n    var lowerLimitFreq = 0;\n    var upperLimitFreq = sampleRate / 2;\n    //Convert the limits to Mel\n    var lowerLimitMel = _freqToMel(lowerLimitFreq);\n    var upperLimitMel = _freqToMel(upperLimitFreq);\n    //Find the range\n    var range = upperLimitMel - lowerLimitMel;\n    //Find the range as part of the linear interpolation\n    var valueToAdd = range / (numFilters + 1);\n    var fftBinsOfFreq = new Array(numFilters + 2);\n    for (var i = 0; i < melValues.length; i++) {\n        // Initialising the mel frequencies\n        // They're a linear interpolation between the lower and upper limits.\n        melValues[i] = i * valueToAdd;\n        // Convert back to Hz\n        melValuesInFreq[i] = _melToFreq(melValues[i]);\n        // Find the corresponding bins\n        fftBinsOfFreq[i] = Math.floor(((bufferSize + 1) * melValuesInFreq[i]) / sampleRate);\n    }\n    var filterBank = new Array(numFilters);\n    for (var j = 0; j < filterBank.length; j++) {\n        // Create a two dimensional array of size numFilters * (buffersize/2)+1\n        // pre-populating the arrays with 0s.\n        filterBank[j] = new Array(bufferSize / 2 + 1).fill(0);\n        //creating the lower and upper slopes for each bin\n        for (var i = fftBinsOfFreq[j]; i < fftBinsOfFreq[j + 1]; i++) {\n            filterBank[j][i] =\n                (i - fftBinsOfFreq[j]) / (fftBinsOfFreq[j + 1] - fftBinsOfFreq[j]);\n        }\n        for (var i = fftBinsOfFreq[j + 1]; i < fftBinsOfFreq[j + 2]; i++) {\n            filterBank[j][i] =\n                (fftBinsOfFreq[j + 2] - i) /\n                    (fftBinsOfFreq[j + 2] - fftBinsOfFreq[j + 1]);\n        }\n    }\n    return filterBank;\n}\nfunction hzToOctaves(freq, A440) {\n    return Math.log2((16 * freq) / A440);\n}\nfunction normalizeByColumn(a) {\n    var emptyRow = a[0].map(function () { return 0; });\n    var colDenominators = a\n        .reduce(function (acc, row) {\n        row.forEach(function (cell, j) {\n            acc[j] += Math.pow(cell, 2);\n        });\n        return acc;\n    }, emptyRow)\n        .map(Math.sqrt);\n    return a.map(function (row, i) { return row.map(function (v, j) { return v / (colDenominators[j] || 1); }); });\n}\nfunction createChromaFilterBank(numFilters, sampleRate, bufferSize, centerOctave, octaveWidth, baseC, A440) {\n    if (centerOctave === void 0) { centerOctave = 5; }\n    if (octaveWidth === void 0) { octaveWidth = 2; }\n    if (baseC === void 0) { baseC = true; }\n    if (A440 === void 0) { A440 = 440; }\n    var numOutputBins = Math.floor(bufferSize / 2) + 1;\n    var frequencyBins = new Array(bufferSize)\n        .fill(0)\n        .map(function (_, i) { return numFilters * hzToOctaves((sampleRate * i) / bufferSize, A440); });\n    // Set a value for the 0 Hz bin that is 1.5 octaves below bin 1\n    // (so chroma is 50% rotated from bin 1, and bin width is broad)\n    frequencyBins[0] = frequencyBins[1] - 1.5 * numFilters;\n    var binWidthBins = frequencyBins\n        .slice(1)\n        .map(function (v, i) { return Math.max(v - frequencyBins[i]); }, 1)\n        .concat([1]);\n    var halfNumFilters = Math.round(numFilters / 2);\n    var filterPeaks = new Array(numFilters)\n        .fill(0)\n        .map(function (_, i) {\n        return frequencyBins.map(function (frq) {\n            return ((10 * numFilters + halfNumFilters + frq - i) % numFilters) -\n                halfNumFilters;\n        });\n    });\n    var weights = filterPeaks.map(function (row, i) {\n        return row.map(function (_, j) {\n            return Math.exp(-0.5 * Math.pow((2 * filterPeaks[i][j]) / binWidthBins[j], 2));\n        });\n    });\n    weights = normalizeByColumn(weights);\n    if (octaveWidth) {\n        var octaveWeights = frequencyBins.map(function (v) {\n            return Math.exp(-0.5 * Math.pow((v / numFilters - centerOctave) / octaveWidth, 2));\n        });\n        weights = weights.map(function (row) {\n            return row.map(function (cell, j) { return cell * octaveWeights[j]; });\n        });\n    }\n    if (baseC) {\n        weights = __spreadArray(__spreadArray([], weights.slice(3), true), weights.slice(0, 3), true);\n    }\n    return weights.map(function (row) { return row.slice(0, numOutputBins); });\n}\nfunction frame(buffer, frameLength, hopLength) {\n    if (buffer.length < frameLength) {\n        throw new Error(\"Buffer is too short for frame length\");\n    }\n    if (hopLength < 1) {\n        throw new Error(\"Hop length cannot be less that 1\");\n    }\n    if (frameLength < 1) {\n        throw new Error(\"Frame length cannot be less that 1\");\n    }\n    var numFrames = 1 + Math.floor((buffer.length - frameLength) / hopLength);\n    return new Array(numFrames)\n        .fill(0)\n        .map(function (_, i) { return buffer.slice(i * hopLength, i * hopLength + frameLength); });\n}\n\nfunction rms (_a) {\n    var signal = _a.signal;\n    // Keeping this bad runtime typecheck for consistency\n    if (typeof signal !== \"object\") {\n        throw new TypeError();\n    }\n    var rms = 0;\n    for (var i = 0; i < signal.length; i++) {\n        rms += Math.pow(signal[i], 2);\n    }\n    rms = rms / signal.length;\n    rms = Math.sqrt(rms);\n    return rms;\n}\n\nfunction energy (_a) {\n    var signal = _a.signal;\n    if (typeof signal !== \"object\") {\n        throw new TypeError();\n    }\n    var energy = 0;\n    for (var i = 0; i < signal.length; i++) {\n        energy += Math.pow(Math.abs(signal[i]), 2);\n    }\n    return energy;\n}\n\nfunction spectralSlope (_a) {\n    var ampSpectrum = _a.ampSpectrum, sampleRate = _a.sampleRate, bufferSize = _a.bufferSize;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    //linear regression\n    var ampSum = 0;\n    var freqSum = 0;\n    var freqs = new Float32Array(ampSpectrum.length);\n    var powFreqSum = 0;\n    var ampFreqSum = 0;\n    for (var i = 0; i < ampSpectrum.length; i++) {\n        ampSum += ampSpectrum[i];\n        var curFreq = (i * sampleRate) / bufferSize;\n        freqs[i] = curFreq;\n        powFreqSum += curFreq * curFreq;\n        freqSum += curFreq;\n        ampFreqSum += curFreq * ampSpectrum[i];\n    }\n    return ((ampSpectrum.length * ampFreqSum - freqSum * ampSum) /\n        (ampSum * (powFreqSum - Math.pow(freqSum, 2))));\n}\n\nfunction mu(i, amplitudeSpect) {\n    var numerator = 0;\n    var denominator = 0;\n    for (var k = 0; k < amplitudeSpect.length; k++) {\n        numerator += Math.pow(k, i) * Math.abs(amplitudeSpect[k]);\n        denominator += amplitudeSpect[k];\n    }\n    return numerator / denominator;\n}\n\nfunction spectralCentroid (_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    return mu(1, ampSpectrum);\n}\n\nfunction spectralRolloff (_a) {\n    var ampSpectrum = _a.ampSpectrum, sampleRate = _a.sampleRate;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    var ampspec = ampSpectrum;\n    //calculate nyquist bin\n    var nyqBin = sampleRate / (2 * (ampspec.length - 1));\n    var ec = 0;\n    for (var i = 0; i < ampspec.length; i++) {\n        ec += ampspec[i];\n    }\n    var threshold = 0.99 * ec;\n    var n = ampspec.length - 1;\n    while (ec > threshold && n >= 0) {\n        ec -= ampspec[n];\n        --n;\n    }\n    return (n + 1) * nyqBin;\n}\n\nfunction spectralFlatness (_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    var numerator = 0;\n    var denominator = 0;\n    for (var i = 0; i < ampSpectrum.length; i++) {\n        numerator += Math.log(ampSpectrum[i]);\n        denominator += ampSpectrum[i];\n    }\n    return ((Math.exp(numerator / ampSpectrum.length) * ampSpectrum.length) /\n        denominator);\n}\n\nfunction spectralSpread (_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    return Math.sqrt(mu(2, ampSpectrum) - Math.pow(mu(1, ampSpectrum), 2));\n}\n\nfunction spectralSkewness (_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    var mu1 = mu(1, ampSpectrum);\n    var mu2 = mu(2, ampSpectrum);\n    var mu3 = mu(3, ampSpectrum);\n    var numerator = 2 * Math.pow(mu1, 3) - 3 * mu1 * mu2 + mu3;\n    var denominator = Math.pow(Math.sqrt(mu2 - Math.pow(mu1, 2)), 3);\n    return numerator / denominator;\n}\n\nfunction spectralKurtosis (_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    var ampspec = ampSpectrum;\n    var mu1 = mu(1, ampspec);\n    var mu2 = mu(2, ampspec);\n    var mu3 = mu(3, ampspec);\n    var mu4 = mu(4, ampspec);\n    var numerator = -3 * Math.pow(mu1, 4) + 6 * mu1 * mu2 - 4 * mu1 * mu3 + mu4;\n    var denominator = Math.pow(Math.sqrt(mu2 - Math.pow(mu1, 2)), 4);\n    return numerator / denominator;\n}\n\nfunction zcr (_a) {\n    var signal = _a.signal;\n    if (typeof signal !== \"object\") {\n        throw new TypeError();\n    }\n    var zcr = 0;\n    for (var i = 1; i < signal.length; i++) {\n        if ((signal[i - 1] >= 0 && signal[i] < 0) ||\n            (signal[i - 1] < 0 && signal[i] >= 0)) {\n            zcr++;\n        }\n    }\n    return zcr;\n}\n\nfunction loudness (_a) {\n    var ampSpectrum = _a.ampSpectrum, barkScale = _a.barkScale, _b = _a.numberOfBarkBands, numberOfBarkBands = _b === void 0 ? 24 : _b;\n    if (typeof ampSpectrum !== \"object\" || typeof barkScale !== \"object\") {\n        throw new TypeError();\n    }\n    var NUM_BARK_BANDS = numberOfBarkBands;\n    var specific = new Float32Array(NUM_BARK_BANDS);\n    var total = 0;\n    var normalisedSpectrum = ampSpectrum;\n    var bbLimits = new Int32Array(NUM_BARK_BANDS + 1);\n    bbLimits[0] = 0;\n    var currentBandEnd = barkScale[normalisedSpectrum.length - 1] / NUM_BARK_BANDS;\n    var currentBand = 1;\n    for (var i = 0; i < normalisedSpectrum.length; i++) {\n        while (barkScale[i] > currentBandEnd) {\n            bbLimits[currentBand++] = i;\n            currentBandEnd =\n                (currentBand * barkScale[normalisedSpectrum.length - 1]) /\n                    NUM_BARK_BANDS;\n        }\n    }\n    bbLimits[NUM_BARK_BANDS] = normalisedSpectrum.length - 1;\n    //process\n    for (var i = 0; i < NUM_BARK_BANDS; i++) {\n        var sum = 0;\n        for (var j = bbLimits[i]; j < bbLimits[i + 1]; j++) {\n            sum += normalisedSpectrum[j];\n        }\n        specific[i] = Math.pow(sum, 0.23);\n    }\n    //get total loudness\n    for (var i = 0; i < specific.length; i++) {\n        total += specific[i];\n    }\n    return {\n        specific: specific,\n        total: total,\n    };\n}\n\nfunction perceptualSpread (_a) {\n    var ampSpectrum = _a.ampSpectrum, barkScale = _a.barkScale;\n    var loudnessValue = loudness({ ampSpectrum: ampSpectrum, barkScale: barkScale });\n    var max = 0;\n    for (var i = 0; i < loudnessValue.specific.length; i++) {\n        if (loudnessValue.specific[i] > max) {\n            max = loudnessValue.specific[i];\n        }\n    }\n    var spread = Math.pow((loudnessValue.total - max) / loudnessValue.total, 2);\n    return spread;\n}\n\nfunction perceptualSharpness (_a) {\n    var ampSpectrum = _a.ampSpectrum, barkScale = _a.barkScale;\n    var loudnessValue = loudness({ ampSpectrum: ampSpectrum, barkScale: barkScale });\n    var spec = loudnessValue.specific;\n    var output = 0;\n    for (var i = 0; i < spec.length; i++) {\n        if (i < 15) {\n            output += (i + 1) * spec[i + 1];\n        }\n        else {\n            output += 0.066 * Math.exp(0.171 * (i + 1));\n        }\n    }\n    output *= 0.11 / loudnessValue.total;\n    return output;\n}\n\nfunction extractPowerSpectrum (_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    var powerSpectrum = new Float32Array(ampSpectrum.length);\n    for (var i = 0; i < powerSpectrum.length; i++) {\n        powerSpectrum[i] = Math.pow(ampSpectrum[i], 2);\n    }\n    return powerSpectrum;\n}\n\nfunction extractMelBands (_a) {\n    var ampSpectrum = _a.ampSpectrum, melFilterBank = _a.melFilterBank, bufferSize = _a.bufferSize;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError(\"Valid ampSpectrum is required to generate melBands\");\n    }\n    if (typeof melFilterBank !== \"object\") {\n        throw new TypeError(\"Valid melFilterBank is required to generate melBands\");\n    }\n    var powSpec = extractPowerSpectrum({ ampSpectrum: ampSpectrum });\n    var numFilters = melFilterBank.length;\n    var filtered = Array(numFilters);\n    var loggedMelBands = new Float32Array(numFilters);\n    for (var i = 0; i < loggedMelBands.length; i++) {\n        filtered[i] = new Float32Array(bufferSize / 2);\n        loggedMelBands[i] = 0;\n        for (var j = 0; j < bufferSize / 2; j++) {\n            //point-wise multiplication between power spectrum and filterbanks.\n            filtered[i][j] = melFilterBank[i][j] * powSpec[j];\n            //summing up all of the coefficients into one array\n            loggedMelBands[i] += filtered[i][j];\n        }\n        //log each coefficient.\n        loggedMelBands[i] = Math.log(loggedMelBands[i] + 1);\n    }\n    return Array.prototype.slice.call(loggedMelBands);\n}\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\n/*===========================================================================*\\\n * Discrete Cosine Transform\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Mel-scale and its related coefficients used in\n * human speech analysis.\n\\*===========================================================================*/\n\nvar cosMap = null;\n\n// Builds a cosine map for the given input size. This allows multiple input sizes to be memoized automagically\n// if you want to run the DCT over and over.\nvar memoizeCosines = function(N) {\n  cosMap = cosMap || {};\n  cosMap[N] = new Array(N*N);\n\n  var PI_N = Math.PI / N;\n\n  for (var k = 0; k < N; k++) {\n    for (var n = 0; n < N; n++) {\n      cosMap[N][n + (k * N)] = Math.cos(PI_N * (n + 0.5) * k);\n    }\n  }\n};\n\nfunction dct$2(signal, scale) {\n  var L = signal.length;\n  scale = scale || 2;\n\n  if (!cosMap || !cosMap[L]) memoizeCosines(L);\n\n  var coefficients = signal.map(function () {return 0;});\n\n  return coefficients.map(function (__, ix) {\n    return scale * signal.reduce(function (prev, cur, ix_, arr) {\n      return prev + (cur * cosMap[L][ix_ + (ix * L)]);\n    }, 0);\n  });\n}\nvar dct_1 = dct$2;\n\nvar dct = dct_1;\n\nvar dct$1 = /*@__PURE__*/getDefaultExportFromCjs(dct);\n\nfunction mfcc (_a) {\n    // Tutorial from:\n    // http://practicalcryptography.com/miscellaneous/machine-learning\n    // /guide-mel-frequency-cepstral-coefficients-mfccs/\n    // @ts-ignore\n    var ampSpectrum = _a.ampSpectrum, melFilterBank = _a.melFilterBank, numberOfMFCCCoefficients = _a.numberOfMFCCCoefficients, bufferSize = _a.bufferSize;\n    var _numberOfMFCCCoefficients = Math.min(40, Math.max(1, numberOfMFCCCoefficients || 13));\n    var numFilters = melFilterBank.length;\n    if (numFilters < _numberOfMFCCCoefficients) {\n        throw new Error(\"Insufficient filter bank for requested number of coefficients\");\n    }\n    var loggedMelBandsArray = extractMelBands({\n        ampSpectrum: ampSpectrum,\n        melFilterBank: melFilterBank,\n        bufferSize: bufferSize,\n    });\n    var mfccs = dct$1(loggedMelBandsArray).slice(0, _numberOfMFCCCoefficients);\n    return mfccs;\n}\n\nfunction chroma (_a) {\n    var ampSpectrum = _a.ampSpectrum, chromaFilterBank = _a.chromaFilterBank;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError(\"Valid ampSpectrum is required to generate chroma\");\n    }\n    if (typeof chromaFilterBank !== \"object\") {\n        throw new TypeError(\"Valid chromaFilterBank is required to generate chroma\");\n    }\n    var chromagram = chromaFilterBank.map(function (row, i) {\n        return ampSpectrum.reduce(function (acc, v, j) { return acc + v * row[j]; }, 0);\n    });\n    var maxVal = Math.max.apply(Math, chromagram);\n    return maxVal ? chromagram.map(function (v) { return v / maxVal; }) : chromagram;\n}\n\n// This file isn't being typechecked at all because there are major issues with it.\n// See #852 for details. Once that's merged, this file should be typechecked.\n// @ts-nocheck\nfunction spectralFlux (_a) {\n    var signal = _a.signal, previousSignal = _a.previousSignal, bufferSize = _a.bufferSize;\n    if (typeof signal !== \"object\" || typeof previousSignal != \"object\") {\n        throw new TypeError();\n    }\n    var sf = 0;\n    for (var i = -(bufferSize / 2); i < signal.length / 2 - 1; i++) {\n        x = Math.abs(signal[i]) - Math.abs(previousSignal[i]);\n        sf += (x + Math.abs(x)) / 2;\n    }\n    return sf;\n}\n\nfunction spectralCrest (_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    var rms = 0;\n    var peak = -Infinity;\n    ampSpectrum.forEach(function (x) {\n        rms += Math.pow(x, 2);\n        peak = x > peak ? x : peak;\n    });\n    rms = rms / ampSpectrum.length;\n    rms = Math.sqrt(rms);\n    return peak / rms;\n}\n\nvar buffer = function (args) {\n    return args.signal;\n};\nvar complexSpectrum = function (args) {\n    return args.complexSpectrum;\n};\nvar amplitudeSpectrum = function (args) {\n    return args.ampSpectrum;\n};\n\nvar extractors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    amplitudeSpectrum: amplitudeSpectrum,\n    buffer: buffer,\n    chroma: chroma,\n    complexSpectrum: complexSpectrum,\n    energy: energy,\n    loudness: loudness,\n    melBands: extractMelBands,\n    mfcc: mfcc,\n    perceptualSharpness: perceptualSharpness,\n    perceptualSpread: perceptualSpread,\n    powerSpectrum: extractPowerSpectrum,\n    rms: rms,\n    spectralCentroid: spectralCentroid,\n    spectralCrest: spectralCrest,\n    spectralFlatness: spectralFlatness,\n    spectralFlux: spectralFlux,\n    spectralKurtosis: spectralKurtosis,\n    spectralRolloff: spectralRolloff,\n    spectralSkewness: spectralSkewness,\n    spectralSlope: spectralSlope,\n    spectralSpread: spectralSpread,\n    zcr: zcr\n});\n\n// memoization of the reversal of different lengths.\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar memoizedReversal = {};\nvar memoizedZeroBuffers = {};\n\nvar constructComplexArray = function constructComplexArray(signal) {\n  var complexSignal = {};\n\n  complexSignal.real = signal.real === undefined ? signal.slice() : signal.real.slice();\n\n  var bufferSize = complexSignal.real.length;\n\n  if (memoizedZeroBuffers[bufferSize] === undefined) {\n    memoizedZeroBuffers[bufferSize] = Array.apply(null, Array(bufferSize)).map(Number.prototype.valueOf, 0);\n  }\n\n  complexSignal.imag = memoizedZeroBuffers[bufferSize].slice();\n\n  return complexSignal;\n};\n\nvar bitReverseArray = function bitReverseArray(N) {\n  if (memoizedReversal[N] === undefined) {\n    var maxBinaryLength = (N - 1).toString(2).length; //get the binary length of the largest index.\n    var templateBinary = '0'.repeat(maxBinaryLength); //create a template binary of that length.\n    var reversed = {};\n    for (var n = 0; n < N; n++) {\n      var currBinary = n.toString(2); //get binary value of current index.\n\n      //prepend zeros from template to current binary. This makes binary values of all indices have the same length.\n      currBinary = templateBinary.substr(currBinary.length) + currBinary;\n\n      currBinary = [].concat(_toConsumableArray(currBinary)).reverse().join(''); //reverse\n      reversed[n] = parseInt(currBinary, 2); //convert to decimal\n    }\n    memoizedReversal[N] = reversed; //save\n  }\n  return memoizedReversal[N];\n};\n\n// complex multiplication\nvar multiply = function multiply(a, b) {\n  return {\n    'real': a.real * b.real - a.imag * b.imag,\n    'imag': a.real * b.imag + a.imag * b.real\n  };\n};\n\n// complex addition\nvar add = function add(a, b) {\n  return {\n    'real': a.real + b.real,\n    'imag': a.imag + b.imag\n  };\n};\n\n// complex subtraction\nvar subtract = function subtract(a, b) {\n  return {\n    'real': a.real - b.real,\n    'imag': a.imag - b.imag\n  };\n};\n\n// euler's identity e^x = cos(x) + sin(x)\nvar euler = function euler(kn, N) {\n  var x = -2 * Math.PI * kn / N;\n  return { 'real': Math.cos(x), 'imag': Math.sin(x) };\n};\n\n// complex conjugate\nvar conj = function conj(a) {\n  a.imag *= -1;\n  return a;\n};\n\nvar utils$1 = {\n  bitReverseArray: bitReverseArray,\n  multiply: multiply,\n  add: add,\n  subtract: subtract,\n  euler: euler,\n  conj: conj,\n  constructComplexArray: constructComplexArray\n};\n\nvar utils = utils$1;\n\n// real to complex fft\nvar fft = function fft(signal) {\n\n  var complexSignal = {};\n\n  if (signal.real === undefined || signal.imag === undefined) {\n    complexSignal = utils.constructComplexArray(signal);\n  } else {\n    complexSignal.real = signal.real.slice();\n    complexSignal.imag = signal.imag.slice();\n  }\n\n  var N = complexSignal.real.length;\n  var logN = Math.log2(N);\n\n  if (Math.round(logN) != logN) throw new Error('Input size must be a power of 2.');\n\n  if (complexSignal.real.length != complexSignal.imag.length) {\n    throw new Error('Real and imaginary components must have the same length.');\n  }\n\n  var bitReversedIndices = utils.bitReverseArray(N);\n\n  // sort array\n  var ordered = {\n    'real': [],\n    'imag': []\n  };\n\n  for (var i = 0; i < N; i++) {\n    ordered.real[bitReversedIndices[i]] = complexSignal.real[i];\n    ordered.imag[bitReversedIndices[i]] = complexSignal.imag[i];\n  }\n\n  for (var _i = 0; _i < N; _i++) {\n    complexSignal.real[_i] = ordered.real[_i];\n    complexSignal.imag[_i] = ordered.imag[_i];\n  }\n  // iterate over the number of stages\n  for (var n = 1; n <= logN; n++) {\n    var currN = Math.pow(2, n);\n\n    // find twiddle factors\n    for (var k = 0; k < currN / 2; k++) {\n      var twiddle = utils.euler(k, currN);\n\n      // on each block of FT, implement the butterfly diagram\n      for (var m = 0; m < N / currN; m++) {\n        var currEvenIndex = currN * m + k;\n        var currOddIndex = currN * m + k + currN / 2;\n\n        var currEvenIndexSample = {\n          'real': complexSignal.real[currEvenIndex],\n          'imag': complexSignal.imag[currEvenIndex]\n        };\n        var currOddIndexSample = {\n          'real': complexSignal.real[currOddIndex],\n          'imag': complexSignal.imag[currOddIndex]\n        };\n\n        var odd = utils.multiply(twiddle, currOddIndexSample);\n\n        var subtractionResult = utils.subtract(currEvenIndexSample, odd);\n        complexSignal.real[currOddIndex] = subtractionResult.real;\n        complexSignal.imag[currOddIndex] = subtractionResult.imag;\n\n        var additionResult = utils.add(odd, currEvenIndexSample);\n        complexSignal.real[currEvenIndex] = additionResult.real;\n        complexSignal.imag[currEvenIndex] = additionResult.imag;\n      }\n    }\n  }\n\n  return complexSignal;\n};\n\n// complex to real ifft\nvar ifft = function ifft(signal) {\n\n  if (signal.real === undefined || signal.imag === undefined) {\n    throw new Error(\"IFFT only accepts a complex input.\");\n  }\n\n  var N = signal.real.length;\n\n  var complexSignal = {\n    'real': [],\n    'imag': []\n  };\n\n  //take complex conjugate in order to be able to use the regular FFT for IFFT\n  for (var i = 0; i < N; i++) {\n    var currentSample = {\n      'real': signal.real[i],\n      'imag': signal.imag[i]\n    };\n\n    var conjugateSample = utils.conj(currentSample);\n    complexSignal.real[i] = conjugateSample.real;\n    complexSignal.imag[i] = conjugateSample.imag;\n  }\n\n  //compute\n  var X = fft(complexSignal);\n\n  //normalize\n  complexSignal.real = X.real.map(function (val) {\n    return val / N;\n  });\n\n  complexSignal.imag = X.imag.map(function (val) {\n    return val / N;\n  });\n\n  return complexSignal;\n};\n\nvar fft_1 = {\n  fft: fft,\n  ifft: ifft\n};\n\n/**\n * Meyda's interface to the Web Audio API. MeydaAnalyzer abstracts an API on\n * top of the Web Audio API's ScriptProcessorNode, running the Meyda audio\n * feature extractors inside that context.\n *\n * MeydaAnalyzer's constructor should not be called directly - MeydaAnalyzer\n * objects should be generated using the {@link createMeydaAnalyzer}\n * factory function in the main Meyda class.\n *\n * Options are of type {@link MeydaAnalyzerOptions}.\n *\n * @example\n * ```javascript\n * const analyzer = Meyda.createMeydaAnalyzer({\n *   \"audioContext\": audioContext,\n *   \"source\": source,\n *   \"bufferSize\": 512,\n *   \"featureExtractors\": [\"rms\"],\n *   \"inputs\": 2,\n *   \"numberOfMFCCCoefficients\": 20\n *   \"callback\": features => {\n *     levelRangeElement.value = features.rms;\n *   }\n * });\n * ```\n */\nvar MeydaAnalyzer = /** @class */ (function () {\n    /** @hidden */\n    function MeydaAnalyzer(options, _this) {\n        var _this_1 = this;\n        this._m = _this;\n        if (!options.audioContext) {\n            throw this._m.errors.noAC;\n        }\n        else if (options.bufferSize &&\n            !isPowerOfTwo(options.bufferSize)) {\n            throw this._m._errors.notPow2;\n        }\n        else if (!options.source) {\n            throw this._m._errors.noSource;\n        }\n        this._m.audioContext = options.audioContext;\n        // TODO: validate options\n        this._m.bufferSize = options.bufferSize || this._m.bufferSize || 256;\n        this._m.hopSize = options.hopSize || this._m.hopSize || this._m.bufferSize;\n        this._m.sampleRate =\n            options.sampleRate || this._m.audioContext.sampleRate || 44100;\n        this._m.callback = options.callback;\n        this._m.windowingFunction = options.windowingFunction || \"hanning\";\n        this._m.featureExtractors = extractors;\n        this._m.EXTRACTION_STARTED = options.startImmediately || false;\n        this._m.channel = typeof options.channel === \"number\" ? options.channel : 0;\n        this._m.inputs = options.inputs || 1;\n        this._m.outputs = options.outputs || 1;\n        this._m.numberOfMFCCCoefficients =\n            options.numberOfMFCCCoefficients ||\n                this._m.numberOfMFCCCoefficients ||\n                13;\n        this._m.numberOfBarkBands =\n            options.numberOfBarkBands || this._m.numberOfBarkBands || 24;\n        //create nodes\n        this._m.spn = this._m.audioContext.createScriptProcessor(this._m.bufferSize, this._m.inputs, this._m.outputs);\n        this._m.spn.connect(this._m.audioContext.destination);\n        this._m._featuresToExtract = options.featureExtractors || [];\n        //always recalculate BS and MFB when a new Meyda analyzer is created.\n        this._m.barkScale = createBarkScale(this._m.bufferSize, this._m.sampleRate, this._m.bufferSize);\n        this._m.melFilterBank = createMelFilterBank(Math.max(this._m.melBands, this._m.numberOfMFCCCoefficients), this._m.sampleRate, this._m.bufferSize);\n        this._m.inputData = null;\n        this._m.previousInputData = null;\n        this._m.frame = null;\n        this._m.previousFrame = null;\n        this.setSource(options.source);\n        this._m.spn.onaudioprocess = function (e) {\n            var buffer;\n            if (_this_1._m.inputData !== null) {\n                _this_1._m.previousInputData = _this_1._m.inputData;\n            }\n            _this_1._m.inputData = e.inputBuffer.getChannelData(_this_1._m.channel);\n            if (!_this_1._m.previousInputData) {\n                buffer = _this_1._m.inputData;\n            }\n            else {\n                buffer = new Float32Array(_this_1._m.previousInputData.length +\n                    _this_1._m.inputData.length -\n                    _this_1._m.hopSize);\n                buffer.set(_this_1._m.previousInputData.slice(_this_1._m.hopSize));\n                buffer.set(_this_1._m.inputData, _this_1._m.previousInputData.length - _this_1._m.hopSize);\n            }\n            var frames = frame(buffer, _this_1._m.bufferSize, _this_1._m.hopSize);\n            frames.forEach(function (f) {\n                _this_1._m.frame = f;\n                var features = _this_1._m.extract(_this_1._m._featuresToExtract, _this_1._m.frame, _this_1._m.previousFrame);\n                // call callback if applicable\n                if (typeof _this_1._m.callback === \"function\" &&\n                    _this_1._m.EXTRACTION_STARTED) {\n                    _this_1._m.callback(features);\n                }\n                _this_1._m.previousFrame = _this_1._m.frame;\n            });\n        };\n    }\n    /**\n     * Start feature extraction\n     * The audio features will be passed to the callback function that was defined\n     * in the MeydaOptions that were passed to the factory when constructing the\n     * MeydaAnalyzer.\n     * @param {(string|Array.<string>)} [features]\n     * Change the features that Meyda is extracting. Defaults to the features that\n     * were set upon construction in the options parameter.\n     * @example\n     * ```javascript\n     * analyzer.start('chroma');\n     * ```\n     */\n    MeydaAnalyzer.prototype.start = function (features) {\n        this._m._featuresToExtract = features || this._m._featuresToExtract;\n        this._m.EXTRACTION_STARTED = true;\n    };\n    /**\n     * Stop feature extraction.\n     * @example\n     * ```javascript\n     * analyzer.stop();\n     * ```\n     */\n    MeydaAnalyzer.prototype.stop = function () {\n        this._m.EXTRACTION_STARTED = false;\n    };\n    /**\n     * Set the Audio Node for Meyda to listen to.\n     * @param {AudioNode} source - The Audio Node for Meyda to listen to\n     * @example\n     * ```javascript\n     * analyzer.setSource(audioSourceNode);\n     * ```\n     */\n    MeydaAnalyzer.prototype.setSource = function (source) {\n        this._m.source && this._m.source.disconnect(this._m.spn);\n        this._m.source = source;\n        this._m.source.connect(this._m.spn);\n    };\n    /**\n     * Set the channel of the audio node for Meyda to listen to\n     * @param {number} channel - the index of the channel on the input audio node\n     * for Meyda to listen to.\n     * @example\n     * ```javascript\n     * analyzer.setChannel(0);\n     * ```\n     */\n    MeydaAnalyzer.prototype.setChannel = function (channel) {\n        if (channel <= this._m.inputs) {\n            this._m.channel = channel;\n        }\n        else {\n            console.error(\"Channel \".concat(channel, \" does not exist. Make sure you've provided a value for 'inputs' that is greater than \").concat(channel, \" when instantiating the MeydaAnalyzer\"));\n        }\n    };\n    /**\n     * Get a set of features from the current frame.\n     * @param {(string|Array.<string>)} [features]\n     * Change the features that Meyda is extracting\n     * @example\n     * ```javascript\n     * analyzer.get('spectralFlatness');\n     * ```\n     */\n    MeydaAnalyzer.prototype.get = function (features) {\n        if (this._m.inputData) {\n            return this._m.extract(features || this._m._featuresToExtract, this._m.inputData, this._m.previousInputData);\n        }\n        else {\n            return null;\n        }\n    };\n    return MeydaAnalyzer;\n}());\n\n/**\n * This file contains the default export for Meyda, you probably want to check\n * out {@link default}\n *\n * @module Meyda\n */\nvar Meyda = {\n    audioContext: null,\n    spn: null,\n    bufferSize: 512,\n    sampleRate: 44100,\n    melBands: 26,\n    chromaBands: 12,\n    callback: null,\n    windowingFunction: \"hanning\",\n    featureExtractors: extractors,\n    EXTRACTION_STARTED: false,\n    numberOfMFCCCoefficients: 13,\n    numberOfBarkBands: 24,\n    _featuresToExtract: [],\n    windowing: applyWindow,\n    /** @hidden */\n    _errors: {\n        notPow2: new Error(\"Meyda: Buffer size must be a power of 2, e.g. 64 or 512\"),\n        featureUndef: new Error(\"Meyda: No features defined.\"),\n        invalidFeatureFmt: new Error(\"Meyda: Invalid feature format\"),\n        invalidInput: new Error(\"Meyda: Invalid input.\"),\n        noAC: new Error(\"Meyda: No AudioContext specified.\"),\n        noSource: new Error(\"Meyda: No source node specified.\"),\n    },\n    /**\n     * @summary\n     * Create a MeydaAnalyzer\n     *\n     * A factory function for creating a MeydaAnalyzer, the interface for using\n     * Meyda in the context of Web Audio.\n     *\n     * ```javascript\n     * const analyzer = Meyda.createMeydaAnalyzer({\n     *   \"audioContext\": audioContext,\n     *   \"source\": source,\n     *   \"bufferSize\": 512,\n     *   \"featureExtractors\": [\"rms\"],\n     *   \"inputs\": 2,\n     *   \"callback\": features => {\n     *     levelRangeElement.value = features.rms;\n     *   }\n     * });\n     * ```\n     */\n    createMeydaAnalyzer: createMeydaAnalyzer,\n    /**\n     * List available audio feature extractors. Return format provides the key to\n     * be used in selecting the extractor in the extract methods\n     */\n    listAvailableFeatureExtractors: listAvailableFeatureExtractors,\n    /**\n     * Extract an audio feature from a buffer\n     *\n     * Unless `meyda.windowingFunction` is set otherwise, `extract` will\n     * internally apply a hanning window to the buffer prior to conversion into\n     * the frequency domain.\n     *\n     * ```javascript\n     * meyda.bufferSize = 2048;\n     * const features = meyda.extract(['zcr', 'spectralCentroid'], signal);\n     * ```\n     */\n    extract: function (feature, signal, previousSignal) {\n        var _this = this;\n        if (!signal)\n            throw this._errors.invalidInput;\n        else if (typeof signal != \"object\")\n            throw this._errors.invalidInput;\n        else if (!feature)\n            throw this._errors.featureUndef;\n        else if (!isPowerOfTwo(signal.length))\n            throw this._errors.notPow2;\n        if (typeof this.barkScale == \"undefined\" ||\n            this.barkScale.length != this.bufferSize) {\n            this.barkScale = createBarkScale(this.bufferSize, this.sampleRate, this.bufferSize);\n        }\n        // Recalculate mel bank if buffer length changed\n        if (typeof this.melFilterBank == \"undefined\" ||\n            this.barkScale.length != this.bufferSize ||\n            this.melFilterBank.length != this.melBands) {\n            this.melFilterBank = createMelFilterBank(Math.max(this.melBands, this.numberOfMFCCCoefficients), this.sampleRate, this.bufferSize);\n        }\n        // Recalculate chroma bank if buffer length changed\n        if (typeof this.chromaFilterBank == \"undefined\" ||\n            this.chromaFilterBank.length != this.chromaBands) {\n            this.chromaFilterBank = createChromaFilterBank(this.chromaBands, this.sampleRate, this.bufferSize);\n        }\n        if (\"buffer\" in signal && typeof signal.buffer == \"undefined\") {\n            //signal is a normal array, convert to F32A\n            this.signal = arrayToTyped(signal);\n        }\n        else {\n            this.signal = signal;\n        }\n        var preparedSignal = prepareSignalWithSpectrum(signal, this.windowingFunction, this.bufferSize);\n        this.signal = preparedSignal.windowedSignal;\n        this.complexSpectrum = preparedSignal.complexSpectrum;\n        this.ampSpectrum = preparedSignal.ampSpectrum;\n        if (previousSignal) {\n            var preparedSignal_1 = prepareSignalWithSpectrum(previousSignal, this.windowingFunction, this.bufferSize);\n            this.previousSignal = preparedSignal_1.windowedSignal;\n            this.previousComplexSpectrum = preparedSignal_1.complexSpectrum;\n            this.previousAmpSpectrum = preparedSignal_1.ampSpectrum;\n        }\n        var extract = function (feature) {\n            return _this.featureExtractors[feature]({\n                ampSpectrum: _this.ampSpectrum,\n                chromaFilterBank: _this.chromaFilterBank,\n                complexSpectrum: _this.complexSpectrum,\n                signal: _this.signal,\n                bufferSize: _this.bufferSize,\n                sampleRate: _this.sampleRate,\n                barkScale: _this.barkScale,\n                melFilterBank: _this.melFilterBank,\n                previousSignal: _this.previousSignal,\n                previousAmpSpectrum: _this.previousAmpSpectrum,\n                previousComplexSpectrum: _this.previousComplexSpectrum,\n                numberOfMFCCCoefficients: _this.numberOfMFCCCoefficients,\n                numberOfBarkBands: _this.numberOfBarkBands,\n            });\n        };\n        if (typeof feature === \"object\") {\n            return feature.reduce(function (acc, el) {\n                var _a;\n                return Object.assign({}, acc, (_a = {},\n                    _a[el] = extract(el),\n                    _a));\n            }, {});\n        }\n        else if (typeof feature === \"string\") {\n            return extract(feature);\n        }\n        else {\n            throw this._errors.invalidFeatureFmt;\n        }\n    },\n};\nvar prepareSignalWithSpectrum = function (signal, windowingFunction, bufferSize) {\n    var preparedSignal = {};\n    if (typeof signal.buffer == \"undefined\") {\n        //signal is a normal array, convert to F32A\n        preparedSignal.signal = arrayToTyped(signal);\n    }\n    else {\n        preparedSignal.signal = signal;\n    }\n    preparedSignal.windowedSignal = applyWindow(preparedSignal.signal, windowingFunction);\n    preparedSignal.complexSpectrum = fft_1.fft(preparedSignal.windowedSignal);\n    preparedSignal.ampSpectrum = new Float32Array(bufferSize / 2);\n    for (var i = 0; i < bufferSize / 2; i++) {\n        preparedSignal.ampSpectrum[i] = Math.sqrt(Math.pow(preparedSignal.complexSpectrum.real[i], 2) +\n            Math.pow(preparedSignal.complexSpectrum.imag[i], 2));\n    }\n    return preparedSignal;\n};\n/**\n * List available audio feature extractors. Return format provides the key to\n * be used in selecting the extractor in the extract methods\n */\nfunction listAvailableFeatureExtractors() {\n    return Object.keys(this.featureExtractors);\n}\n/**\n * Create a MeydaAnalyzer\n *\n * A factory function for creating a MeydaAnalyzer, the interface for using\n * Meyda in the context of Web Audio.\n *\n * ```javascript\n * const analyzer = Meyda.createMeydaAnalyzer({\n *   \"audioContext\": audioContext,\n *   \"source\": source,\n *   \"bufferSize\": 512,\n *   \"featureExtractors\": [\"rms\"],\n *   \"inputs\": 2,\n *   \"callback\": features => {\n *     levelRangeElement.value = features.rms;\n *   }\n * });\n * ```\n */\nfunction createMeydaAnalyzer(options) {\n    return new MeydaAnalyzer(options, Object.assign({}, Meyda));\n}\n// @ts-ignore\nif (typeof window !== \"undefined\")\n    window.Meyda = Meyda;\n\nmodule.exports = Meyda;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWV5ZGEvZGlzdC9ub2RlL21haW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXRoZXJhcGlzdC8uL25vZGVfbW9kdWxlcy9tZXlkYS9kaXN0L25vZGUvbWFpbi5qcz8yNDY2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxuXG5mdW5jdGlvbiBibGFja21hbihzaXplKSB7XG4gICAgdmFyIGJsYWNrbWFuQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICB2YXIgY29lZmYxID0gKDIgKiBNYXRoLlBJKSAvIChzaXplIC0gMSk7XG4gICAgdmFyIGNvZWZmMiA9IDIgKiBjb2VmZjE7XG4gICAgLy9BY2NvcmRpbmcgdG8gaHR0cDovL3VrLm1hdGh3b3Jrcy5jb20vaGVscC9zaWduYWwvcmVmL2JsYWNrbWFuLmh0bWxcbiAgICAvL2ZpcnN0IGhhbGYgb2YgdGhlIHdpbmRvd1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZSAvIDI7IGkrKykge1xuICAgICAgICBibGFja21hbkJ1ZmZlcltpXSA9XG4gICAgICAgICAgICAwLjQyIC0gMC41ICogTWF0aC5jb3MoaSAqIGNvZWZmMSkgKyAwLjA4ICogTWF0aC5jb3MoaSAqIGNvZWZmMik7XG4gICAgfVxuICAgIC8vc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvd1xuICAgIGZvciAodmFyIGkgPSBNYXRoLmNlaWwoc2l6ZSAvIDIpOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGJsYWNrbWFuQnVmZmVyW3NpemUgLSBpXSA9IGJsYWNrbWFuQnVmZmVyW2kgLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGJsYWNrbWFuQnVmZmVyO1xufVxuZnVuY3Rpb24gc2luZShzaXplKSB7XG4gICAgdmFyIGNvZWZmID0gTWF0aC5QSSAvIChzaXplIC0gMSk7XG4gICAgdmFyIHNpbmVCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHNpbmVCdWZmZXJbaV0gPSBNYXRoLnNpbihjb2VmZiAqIGkpO1xuICAgIH1cbiAgICByZXR1cm4gc2luZUJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGhhbm5pbmcoc2l6ZSkge1xuICAgIHZhciBoYW5uaW5nQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIFIgZG9jdW1lbnRhdGlvblxuICAgICAgICAvLyBodHRwOi8vdWdyYWQuc3RhdC51YmMuY2EvUi9saWJyYXJ5L2UxMDcxL2h0bWwvaGFubmluZy53aW5kb3cuaHRtbFxuICAgICAgICBoYW5uaW5nQnVmZmVyW2ldID0gMC41IC0gMC41ICogTWF0aC5jb3MoKDIgKiBNYXRoLlBJICogaSkgLyAoc2l6ZSAtIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbm5pbmdCdWZmZXI7XG59XG5mdW5jdGlvbiBoYW1taW5nKHNpemUpIHtcbiAgICB2YXIgaGFtbWluZ0J1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgLy9BY2NvcmRpbmcgdG8gaHR0cDovL3VrLm1hdGh3b3Jrcy5jb20vaGVscC9zaWduYWwvcmVmL2hhbW1pbmcuaHRtbFxuICAgICAgICBoYW1taW5nQnVmZmVyW2ldID0gMC41NCAtIDAuNDYgKiBNYXRoLmNvcygyICogTWF0aC5QSSAqIChpIC8gc2l6ZSAtIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbW1pbmdCdWZmZXI7XG59XG5cbnZhciB3aW5kb3dpbmcgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGJsYWNrbWFuOiBibGFja21hbixcbiAgICBoYW1taW5nOiBoYW1taW5nLFxuICAgIGhhbm5pbmc6IGhhbm5pbmcsXG4gICAgc2luZTogc2luZVxufSk7XG5cbnZhciB3aW5kb3dzID0ge307XG5mdW5jdGlvbiBpc1Bvd2VyT2ZUd28obnVtKSB7XG4gICAgd2hpbGUgKG51bSAlIDIgPT09IDAgJiYgbnVtID4gMSkge1xuICAgICAgICBudW0gLz0gMjtcbiAgICB9XG4gICAgcmV0dXJuIG51bSA9PT0gMTtcbn1cbmZ1bmN0aW9uIHBvaW50d2lzZUJ1ZmZlck11bHQoYSwgYikge1xuICAgIHZhciBjID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgY1tpXSA9IGFbaV0gKiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIGFwcGx5V2luZG93KHNpZ25hbCwgd2luZG93bmFtZSkge1xuICAgIGlmICh3aW5kb3duYW1lICE9PSBcInJlY3RcIikge1xuICAgICAgICBpZiAod2luZG93bmFtZSA9PT0gXCJcIiB8fCAhd2luZG93bmFtZSlcbiAgICAgICAgICAgIHdpbmRvd25hbWUgPSBcImhhbm5pbmdcIjtcbiAgICAgICAgaWYgKCF3aW5kb3dzW3dpbmRvd25hbWVdKVxuICAgICAgICAgICAgd2luZG93c1t3aW5kb3duYW1lXSA9IHt9O1xuICAgICAgICBpZiAoIXdpbmRvd3Nbd2luZG93bmFtZV1bc2lnbmFsLmxlbmd0aF0pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93c1t3aW5kb3duYW1lXVtzaWduYWwubGVuZ3RoXSA9IHdpbmRvd2luZ1t3aW5kb3duYW1lXShzaWduYWwubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3aW5kb3dpbmcgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsID0gcG9pbnR3aXNlQnVmZmVyTXVsdChzaWduYWwsIHdpbmRvd3Nbd2luZG93bmFtZV1bc2lnbmFsLmxlbmd0aF0pO1xuICAgIH1cbiAgICByZXR1cm4gc2lnbmFsO1xufVxuZnVuY3Rpb24gY3JlYXRlQmFya1NjYWxlKGxlbmd0aCwgc2FtcGxlUmF0ZSwgYnVmZmVyU2l6ZSkge1xuICAgIHZhciBiYXJrU2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXJrU2NhbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmFya1NjYWxlW2ldID0gKGkgKiBzYW1wbGVSYXRlKSAvIGJ1ZmZlclNpemU7XG4gICAgICAgIGJhcmtTY2FsZVtpXSA9XG4gICAgICAgICAgICAxMyAqIE1hdGguYXRhbihiYXJrU2NhbGVbaV0gLyAxMzE1LjgpICtcbiAgICAgICAgICAgICAgICAzLjUgKiBNYXRoLmF0YW4oTWF0aC5wb3coYmFya1NjYWxlW2ldIC8gNzUxOCwgMikpO1xuICAgIH1cbiAgICByZXR1cm4gYmFya1NjYWxlO1xufVxuZnVuY3Rpb24gYXJyYXlUb1R5cGVkKHQpIHtcbiAgICAvLyB1dGlsaXR5IHRvIGNvbnZlcnQgYXJyYXlzIHRvIHR5cGVkIEYzMiBhcnJheXNcbiAgICByZXR1cm4gRmxvYXQzMkFycmF5LmZyb20odCk7XG59XG5mdW5jdGlvbiBfbWVsVG9GcmVxKG1lbFZhbHVlKSB7XG4gICAgdmFyIGZyZXFWYWx1ZSA9IDcwMCAqIChNYXRoLmV4cChtZWxWYWx1ZSAvIDExMjUpIC0gMSk7XG4gICAgcmV0dXJuIGZyZXFWYWx1ZTtcbn1cbmZ1bmN0aW9uIF9mcmVxVG9NZWwoZnJlcVZhbHVlKSB7XG4gICAgdmFyIG1lbFZhbHVlID0gMTEyNSAqIE1hdGgubG9nKDEgKyBmcmVxVmFsdWUgLyA3MDApO1xuICAgIHJldHVybiBtZWxWYWx1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lbEZpbHRlckJhbmsobnVtRmlsdGVycywgc2FtcGxlUmF0ZSwgYnVmZmVyU2l6ZSkge1xuICAgIC8vdGhlICsyIGlzIHRoZSB1cHBlciBhbmQgbG93ZXIgbGltaXRzXG4gICAgdmFyIG1lbFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtRmlsdGVycyArIDIpO1xuICAgIHZhciBtZWxWYWx1ZXNJbkZyZXEgPSBuZXcgRmxvYXQzMkFycmF5KG51bUZpbHRlcnMgKyAyKTtcbiAgICAvL0dlbmVyYXRlIGxpbWl0cyBpbiBIeiAtIGZyb20gMCB0byB0aGUgbnlxdWlzdC5cbiAgICB2YXIgbG93ZXJMaW1pdEZyZXEgPSAwO1xuICAgIHZhciB1cHBlckxpbWl0RnJlcSA9IHNhbXBsZVJhdGUgLyAyO1xuICAgIC8vQ29udmVydCB0aGUgbGltaXRzIHRvIE1lbFxuICAgIHZhciBsb3dlckxpbWl0TWVsID0gX2ZyZXFUb01lbChsb3dlckxpbWl0RnJlcSk7XG4gICAgdmFyIHVwcGVyTGltaXRNZWwgPSBfZnJlcVRvTWVsKHVwcGVyTGltaXRGcmVxKTtcbiAgICAvL0ZpbmQgdGhlIHJhbmdlXG4gICAgdmFyIHJhbmdlID0gdXBwZXJMaW1pdE1lbCAtIGxvd2VyTGltaXRNZWw7XG4gICAgLy9GaW5kIHRoZSByYW5nZSBhcyBwYXJ0IG9mIHRoZSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgIHZhciB2YWx1ZVRvQWRkID0gcmFuZ2UgLyAobnVtRmlsdGVycyArIDEpO1xuICAgIHZhciBmZnRCaW5zT2ZGcmVxID0gbmV3IEFycmF5KG51bUZpbHRlcnMgKyAyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lbFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBJbml0aWFsaXNpbmcgdGhlIG1lbCBmcmVxdWVuY2llc1xuICAgICAgICAvLyBUaGV5J3JlIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0aGUgbG93ZXIgYW5kIHVwcGVyIGxpbWl0cy5cbiAgICAgICAgbWVsVmFsdWVzW2ldID0gaSAqIHZhbHVlVG9BZGQ7XG4gICAgICAgIC8vIENvbnZlcnQgYmFjayB0byBIelxuICAgICAgICBtZWxWYWx1ZXNJbkZyZXFbaV0gPSBfbWVsVG9GcmVxKG1lbFZhbHVlc1tpXSk7XG4gICAgICAgIC8vIEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgYmluc1xuICAgICAgICBmZnRCaW5zT2ZGcmVxW2ldID0gTWF0aC5mbG9vcigoKGJ1ZmZlclNpemUgKyAxKSAqIG1lbFZhbHVlc0luRnJlcVtpXSkgLyBzYW1wbGVSYXRlKTtcbiAgICB9XG4gICAgdmFyIGZpbHRlckJhbmsgPSBuZXcgQXJyYXkobnVtRmlsdGVycyk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWx0ZXJCYW5rLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHR3byBkaW1lbnNpb25hbCBhcnJheSBvZiBzaXplIG51bUZpbHRlcnMgKiAoYnVmZmVyc2l6ZS8yKSsxXG4gICAgICAgIC8vIHByZS1wb3B1bGF0aW5nIHRoZSBhcnJheXMgd2l0aCAwcy5cbiAgICAgICAgZmlsdGVyQmFua1tqXSA9IG5ldyBBcnJheShidWZmZXJTaXplIC8gMiArIDEpLmZpbGwoMCk7XG4gICAgICAgIC8vY3JlYXRpbmcgdGhlIGxvd2VyIGFuZCB1cHBlciBzbG9wZXMgZm9yIGVhY2ggYmluXG4gICAgICAgIGZvciAodmFyIGkgPSBmZnRCaW5zT2ZGcmVxW2pdOyBpIDwgZmZ0Qmluc09mRnJlcVtqICsgMV07IGkrKykge1xuICAgICAgICAgICAgZmlsdGVyQmFua1tqXVtpXSA9XG4gICAgICAgICAgICAgICAgKGkgLSBmZnRCaW5zT2ZGcmVxW2pdKSAvIChmZnRCaW5zT2ZGcmVxW2ogKyAxXSAtIGZmdEJpbnNPZkZyZXFbal0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBmZnRCaW5zT2ZGcmVxW2ogKyAxXTsgaSA8IGZmdEJpbnNPZkZyZXFbaiArIDJdOyBpKyspIHtcbiAgICAgICAgICAgIGZpbHRlckJhbmtbal1baV0gPVxuICAgICAgICAgICAgICAgIChmZnRCaW5zT2ZGcmVxW2ogKyAyXSAtIGkpIC9cbiAgICAgICAgICAgICAgICAgICAgKGZmdEJpbnNPZkZyZXFbaiArIDJdIC0gZmZ0Qmluc09mRnJlcVtqICsgMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJCYW5rO1xufVxuZnVuY3Rpb24gaHpUb09jdGF2ZXMoZnJlcSwgQTQ0MCkge1xuICAgIHJldHVybiBNYXRoLmxvZzIoKDE2ICogZnJlcSkgLyBBNDQwKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJ5Q29sdW1uKGEpIHtcbiAgICB2YXIgZW1wdHlSb3cgPSBhWzBdLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9KTtcbiAgICB2YXIgY29sRGVub21pbmF0b3JzID0gYVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHJvdykge1xuICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCwgaikge1xuICAgICAgICAgICAgYWNjW2pdICs9IE1hdGgucG93KGNlbGwsIDIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBlbXB0eVJvdylcbiAgICAgICAgLm1hcChNYXRoLnNxcnQpO1xuICAgIHJldHVybiBhLm1hcChmdW5jdGlvbiAocm93LCBpKSB7IHJldHVybiByb3cubWFwKGZ1bmN0aW9uICh2LCBqKSB7IHJldHVybiB2IC8gKGNvbERlbm9taW5hdG9yc1tqXSB8fCAxKTsgfSk7IH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2hyb21hRmlsdGVyQmFuayhudW1GaWx0ZXJzLCBzYW1wbGVSYXRlLCBidWZmZXJTaXplLCBjZW50ZXJPY3RhdmUsIG9jdGF2ZVdpZHRoLCBiYXNlQywgQTQ0MCkge1xuICAgIGlmIChjZW50ZXJPY3RhdmUgPT09IHZvaWQgMCkgeyBjZW50ZXJPY3RhdmUgPSA1OyB9XG4gICAgaWYgKG9jdGF2ZVdpZHRoID09PSB2b2lkIDApIHsgb2N0YXZlV2lkdGggPSAyOyB9XG4gICAgaWYgKGJhc2VDID09PSB2b2lkIDApIHsgYmFzZUMgPSB0cnVlOyB9XG4gICAgaWYgKEE0NDAgPT09IHZvaWQgMCkgeyBBNDQwID0gNDQwOyB9XG4gICAgdmFyIG51bU91dHB1dEJpbnMgPSBNYXRoLmZsb29yKGJ1ZmZlclNpemUgLyAyKSArIDE7XG4gICAgdmFyIGZyZXF1ZW5jeUJpbnMgPSBuZXcgQXJyYXkoYnVmZmVyU2l6ZSlcbiAgICAgICAgLmZpbGwoMClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gbnVtRmlsdGVycyAqIGh6VG9PY3RhdmVzKChzYW1wbGVSYXRlICogaSkgLyBidWZmZXJTaXplLCBBNDQwKTsgfSk7XG4gICAgLy8gU2V0IGEgdmFsdWUgZm9yIHRoZSAwIEh6IGJpbiB0aGF0IGlzIDEuNSBvY3RhdmVzIGJlbG93IGJpbiAxXG4gICAgLy8gKHNvIGNocm9tYSBpcyA1MCUgcm90YXRlZCBmcm9tIGJpbiAxLCBhbmQgYmluIHdpZHRoIGlzIGJyb2FkKVxuICAgIGZyZXF1ZW5jeUJpbnNbMF0gPSBmcmVxdWVuY3lCaW5zWzFdIC0gMS41ICogbnVtRmlsdGVycztcbiAgICB2YXIgYmluV2lkdGhCaW5zID0gZnJlcXVlbmN5Qmluc1xuICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gTWF0aC5tYXgodiAtIGZyZXF1ZW5jeUJpbnNbaV0pOyB9LCAxKVxuICAgICAgICAuY29uY2F0KFsxXSk7XG4gICAgdmFyIGhhbGZOdW1GaWx0ZXJzID0gTWF0aC5yb3VuZChudW1GaWx0ZXJzIC8gMik7XG4gICAgdmFyIGZpbHRlclBlYWtzID0gbmV3IEFycmF5KG51bUZpbHRlcnMpXG4gICAgICAgIC5maWxsKDApXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgICAgcmV0dXJuIGZyZXF1ZW5jeUJpbnMubWFwKGZ1bmN0aW9uIChmcnEpIHtcbiAgICAgICAgICAgIHJldHVybiAoKDEwICogbnVtRmlsdGVycyArIGhhbGZOdW1GaWx0ZXJzICsgZnJxIC0gaSkgJSBudW1GaWx0ZXJzKSAtXG4gICAgICAgICAgICAgICAgaGFsZk51bUZpbHRlcnM7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciB3ZWlnaHRzID0gZmlsdGVyUGVha3MubWFwKGZ1bmN0aW9uIChyb3csIGkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24gKF8sIGopIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmV4cCgtMC41ICogTWF0aC5wb3coKDIgKiBmaWx0ZXJQZWFrc1tpXVtqXSkgLyBiaW5XaWR0aEJpbnNbal0sIDIpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgd2VpZ2h0cyA9IG5vcm1hbGl6ZUJ5Q29sdW1uKHdlaWdodHMpO1xuICAgIGlmIChvY3RhdmVXaWR0aCkge1xuICAgICAgICB2YXIgb2N0YXZlV2VpZ2h0cyA9IGZyZXF1ZW5jeUJpbnMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5leHAoLTAuNSAqIE1hdGgucG93KCh2IC8gbnVtRmlsdGVycyAtIGNlbnRlck9jdGF2ZSkgLyBvY3RhdmVXaWR0aCwgMikpO1xuICAgICAgICB9KTtcbiAgICAgICAgd2VpZ2h0cyA9IHdlaWdodHMubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiByb3cubWFwKGZ1bmN0aW9uIChjZWxsLCBqKSB7IHJldHVybiBjZWxsICogb2N0YXZlV2VpZ2h0c1tqXTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYmFzZUMpIHtcbiAgICAgICAgd2VpZ2h0cyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgd2VpZ2h0cy5zbGljZSgzKSwgdHJ1ZSksIHdlaWdodHMuc2xpY2UoMCwgMyksIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gd2VpZ2h0cy5tYXAoZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93LnNsaWNlKDAsIG51bU91dHB1dEJpbnMpOyB9KTtcbn1cbmZ1bmN0aW9uIGZyYW1lKGJ1ZmZlciwgZnJhbWVMZW5ndGgsIGhvcExlbmd0aCkge1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgZnJhbWVMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyIGlzIHRvbyBzaG9ydCBmb3IgZnJhbWUgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICBpZiAoaG9wTGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIb3AgbGVuZ3RoIGNhbm5vdCBiZSBsZXNzIHRoYXQgMVwiKTtcbiAgICB9XG4gICAgaWYgKGZyYW1lTGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcmFtZSBsZW5ndGggY2Fubm90IGJlIGxlc3MgdGhhdCAxXCIpO1xuICAgIH1cbiAgICB2YXIgbnVtRnJhbWVzID0gMSArIE1hdGguZmxvb3IoKGJ1ZmZlci5sZW5ndGggLSBmcmFtZUxlbmd0aCkgLyBob3BMZW5ndGgpO1xuICAgIHJldHVybiBuZXcgQXJyYXkobnVtRnJhbWVzKVxuICAgICAgICAuZmlsbCgwKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiBidWZmZXIuc2xpY2UoaSAqIGhvcExlbmd0aCwgaSAqIGhvcExlbmd0aCArIGZyYW1lTGVuZ3RoKTsgfSk7XG59XG5cbmZ1bmN0aW9uIHJtcyAoX2EpIHtcbiAgICB2YXIgc2lnbmFsID0gX2Euc2lnbmFsO1xuICAgIC8vIEtlZXBpbmcgdGhpcyBiYWQgcnVudGltZSB0eXBlY2hlY2sgZm9yIGNvbnNpc3RlbmN5XG4gICAgaWYgKHR5cGVvZiBzaWduYWwgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgcm1zID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ25hbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBybXMgKz0gTWF0aC5wb3coc2lnbmFsW2ldLCAyKTtcbiAgICB9XG4gICAgcm1zID0gcm1zIC8gc2lnbmFsLmxlbmd0aDtcbiAgICBybXMgPSBNYXRoLnNxcnQocm1zKTtcbiAgICByZXR1cm4gcm1zO1xufVxuXG5mdW5jdGlvbiBlbmVyZ3kgKF9hKSB7XG4gICAgdmFyIHNpZ25hbCA9IF9hLnNpZ25hbDtcbiAgICBpZiAodHlwZW9mIHNpZ25hbCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIHZhciBlbmVyZ3kgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVuZXJneSArPSBNYXRoLnBvdyhNYXRoLmFicyhzaWduYWxbaV0pLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZXJneTtcbn1cblxuZnVuY3Rpb24gc3BlY3RyYWxTbG9wZSAoX2EpIHtcbiAgICB2YXIgYW1wU3BlY3RydW0gPSBfYS5hbXBTcGVjdHJ1bSwgc2FtcGxlUmF0ZSA9IF9hLnNhbXBsZVJhdGUsIGJ1ZmZlclNpemUgPSBfYS5idWZmZXJTaXplO1xuICAgIGlmICh0eXBlb2YgYW1wU3BlY3RydW0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICAvL2xpbmVhciByZWdyZXNzaW9uXG4gICAgdmFyIGFtcFN1bSA9IDA7XG4gICAgdmFyIGZyZXFTdW0gPSAwO1xuICAgIHZhciBmcmVxcyA9IG5ldyBGbG9hdDMyQXJyYXkoYW1wU3BlY3RydW0ubGVuZ3RoKTtcbiAgICB2YXIgcG93RnJlcVN1bSA9IDA7XG4gICAgdmFyIGFtcEZyZXFTdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1wU3BlY3RydW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYW1wU3VtICs9IGFtcFNwZWN0cnVtW2ldO1xuICAgICAgICB2YXIgY3VyRnJlcSA9IChpICogc2FtcGxlUmF0ZSkgLyBidWZmZXJTaXplO1xuICAgICAgICBmcmVxc1tpXSA9IGN1ckZyZXE7XG4gICAgICAgIHBvd0ZyZXFTdW0gKz0gY3VyRnJlcSAqIGN1ckZyZXE7XG4gICAgICAgIGZyZXFTdW0gKz0gY3VyRnJlcTtcbiAgICAgICAgYW1wRnJlcVN1bSArPSBjdXJGcmVxICogYW1wU3BlY3RydW1baV07XG4gICAgfVxuICAgIHJldHVybiAoKGFtcFNwZWN0cnVtLmxlbmd0aCAqIGFtcEZyZXFTdW0gLSBmcmVxU3VtICogYW1wU3VtKSAvXG4gICAgICAgIChhbXBTdW0gKiAocG93RnJlcVN1bSAtIE1hdGgucG93KGZyZXFTdW0sIDIpKSkpO1xufVxuXG5mdW5jdGlvbiBtdShpLCBhbXBsaXR1ZGVTcGVjdCkge1xuICAgIHZhciBudW1lcmF0b3IgPSAwO1xuICAgIHZhciBkZW5vbWluYXRvciA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBhbXBsaXR1ZGVTcGVjdC5sZW5ndGg7IGsrKykge1xuICAgICAgICBudW1lcmF0b3IgKz0gTWF0aC5wb3coaywgaSkgKiBNYXRoLmFicyhhbXBsaXR1ZGVTcGVjdFtrXSk7XG4gICAgICAgIGRlbm9taW5hdG9yICs9IGFtcGxpdHVkZVNwZWN0W2tdO1xuICAgIH1cbiAgICByZXR1cm4gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG59XG5cbmZ1bmN0aW9uIHNwZWN0cmFsQ2VudHJvaWQgKF9hKSB7XG4gICAgdmFyIGFtcFNwZWN0cnVtID0gX2EuYW1wU3BlY3RydW07XG4gICAgaWYgKHR5cGVvZiBhbXBTcGVjdHJ1bSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiBtdSgxLCBhbXBTcGVjdHJ1bSk7XG59XG5cbmZ1bmN0aW9uIHNwZWN0cmFsUm9sbG9mZiAoX2EpIHtcbiAgICB2YXIgYW1wU3BlY3RydW0gPSBfYS5hbXBTcGVjdHJ1bSwgc2FtcGxlUmF0ZSA9IF9hLnNhbXBsZVJhdGU7XG4gICAgaWYgKHR5cGVvZiBhbXBTcGVjdHJ1bSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIHZhciBhbXBzcGVjID0gYW1wU3BlY3RydW07XG4gICAgLy9jYWxjdWxhdGUgbnlxdWlzdCBiaW5cbiAgICB2YXIgbnlxQmluID0gc2FtcGxlUmF0ZSAvICgyICogKGFtcHNwZWMubGVuZ3RoIC0gMSkpO1xuICAgIHZhciBlYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbXBzcGVjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVjICs9IGFtcHNwZWNbaV07XG4gICAgfVxuICAgIHZhciB0aHJlc2hvbGQgPSAwLjk5ICogZWM7XG4gICAgdmFyIG4gPSBhbXBzcGVjLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGVjID4gdGhyZXNob2xkICYmIG4gPj0gMCkge1xuICAgICAgICBlYyAtPSBhbXBzcGVjW25dO1xuICAgICAgICAtLW47XG4gICAgfVxuICAgIHJldHVybiAobiArIDEpICogbnlxQmluO1xufVxuXG5mdW5jdGlvbiBzcGVjdHJhbEZsYXRuZXNzIChfYSkge1xuICAgIHZhciBhbXBTcGVjdHJ1bSA9IF9hLmFtcFNwZWN0cnVtO1xuICAgIGlmICh0eXBlb2YgYW1wU3BlY3RydW0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgbnVtZXJhdG9yID0gMDtcbiAgICB2YXIgZGVub21pbmF0b3IgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1wU3BlY3RydW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbnVtZXJhdG9yICs9IE1hdGgubG9nKGFtcFNwZWN0cnVtW2ldKTtcbiAgICAgICAgZGVub21pbmF0b3IgKz0gYW1wU3BlY3RydW1baV07XG4gICAgfVxuICAgIHJldHVybiAoKE1hdGguZXhwKG51bWVyYXRvciAvIGFtcFNwZWN0cnVtLmxlbmd0aCkgKiBhbXBTcGVjdHJ1bS5sZW5ndGgpIC9cbiAgICAgICAgZGVub21pbmF0b3IpO1xufVxuXG5mdW5jdGlvbiBzcGVjdHJhbFNwcmVhZCAoX2EpIHtcbiAgICB2YXIgYW1wU3BlY3RydW0gPSBfYS5hbXBTcGVjdHJ1bTtcbiAgICBpZiAodHlwZW9mIGFtcFNwZWN0cnVtICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguc3FydChtdSgyLCBhbXBTcGVjdHJ1bSkgLSBNYXRoLnBvdyhtdSgxLCBhbXBTcGVjdHJ1bSksIDIpKTtcbn1cblxuZnVuY3Rpb24gc3BlY3RyYWxTa2V3bmVzcyAoX2EpIHtcbiAgICB2YXIgYW1wU3BlY3RydW0gPSBfYS5hbXBTcGVjdHJ1bTtcbiAgICBpZiAodHlwZW9mIGFtcFNwZWN0cnVtICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIG11MSA9IG11KDEsIGFtcFNwZWN0cnVtKTtcbiAgICB2YXIgbXUyID0gbXUoMiwgYW1wU3BlY3RydW0pO1xuICAgIHZhciBtdTMgPSBtdSgzLCBhbXBTcGVjdHJ1bSk7XG4gICAgdmFyIG51bWVyYXRvciA9IDIgKiBNYXRoLnBvdyhtdTEsIDMpIC0gMyAqIG11MSAqIG11MiArIG11MztcbiAgICB2YXIgZGVub21pbmF0b3IgPSBNYXRoLnBvdyhNYXRoLnNxcnQobXUyIC0gTWF0aC5wb3cobXUxLCAyKSksIDMpO1xuICAgIHJldHVybiBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbn1cblxuZnVuY3Rpb24gc3BlY3RyYWxLdXJ0b3NpcyAoX2EpIHtcbiAgICB2YXIgYW1wU3BlY3RydW0gPSBfYS5hbXBTcGVjdHJ1bTtcbiAgICBpZiAodHlwZW9mIGFtcFNwZWN0cnVtICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIGFtcHNwZWMgPSBhbXBTcGVjdHJ1bTtcbiAgICB2YXIgbXUxID0gbXUoMSwgYW1wc3BlYyk7XG4gICAgdmFyIG11MiA9IG11KDIsIGFtcHNwZWMpO1xuICAgIHZhciBtdTMgPSBtdSgzLCBhbXBzcGVjKTtcbiAgICB2YXIgbXU0ID0gbXUoNCwgYW1wc3BlYyk7XG4gICAgdmFyIG51bWVyYXRvciA9IC0zICogTWF0aC5wb3cobXUxLCA0KSArIDYgKiBtdTEgKiBtdTIgLSA0ICogbXUxICogbXUzICsgbXU0O1xuICAgIHZhciBkZW5vbWluYXRvciA9IE1hdGgucG93KE1hdGguc3FydChtdTIgLSBNYXRoLnBvdyhtdTEsIDIpKSwgNCk7XG4gICAgcmV0dXJuIG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xufVxuXG5mdW5jdGlvbiB6Y3IgKF9hKSB7XG4gICAgdmFyIHNpZ25hbCA9IF9hLnNpZ25hbDtcbiAgICBpZiAodHlwZW9mIHNpZ25hbCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIHZhciB6Y3IgPSAwO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2lnbmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoc2lnbmFsW2kgLSAxXSA+PSAwICYmIHNpZ25hbFtpXSA8IDApIHx8XG4gICAgICAgICAgICAoc2lnbmFsW2kgLSAxXSA8IDAgJiYgc2lnbmFsW2ldID49IDApKSB7XG4gICAgICAgICAgICB6Y3IrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gemNyO1xufVxuXG5mdW5jdGlvbiBsb3VkbmVzcyAoX2EpIHtcbiAgICB2YXIgYW1wU3BlY3RydW0gPSBfYS5hbXBTcGVjdHJ1bSwgYmFya1NjYWxlID0gX2EuYmFya1NjYWxlLCBfYiA9IF9hLm51bWJlck9mQmFya0JhbmRzLCBudW1iZXJPZkJhcmtCYW5kcyA9IF9iID09PSB2b2lkIDAgPyAyNCA6IF9iO1xuICAgIGlmICh0eXBlb2YgYW1wU3BlY3RydW0gIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGJhcmtTY2FsZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIHZhciBOVU1fQkFSS19CQU5EUyA9IG51bWJlck9mQmFya0JhbmRzO1xuICAgIHZhciBzcGVjaWZpYyA9IG5ldyBGbG9hdDMyQXJyYXkoTlVNX0JBUktfQkFORFMpO1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdmFyIG5vcm1hbGlzZWRTcGVjdHJ1bSA9IGFtcFNwZWN0cnVtO1xuICAgIHZhciBiYkxpbWl0cyA9IG5ldyBJbnQzMkFycmF5KE5VTV9CQVJLX0JBTkRTICsgMSk7XG4gICAgYmJMaW1pdHNbMF0gPSAwO1xuICAgIHZhciBjdXJyZW50QmFuZEVuZCA9IGJhcmtTY2FsZVtub3JtYWxpc2VkU3BlY3RydW0ubGVuZ3RoIC0gMV0gLyBOVU1fQkFSS19CQU5EUztcbiAgICB2YXIgY3VycmVudEJhbmQgPSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9ybWFsaXNlZFNwZWN0cnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChiYXJrU2NhbGVbaV0gPiBjdXJyZW50QmFuZEVuZCkge1xuICAgICAgICAgICAgYmJMaW1pdHNbY3VycmVudEJhbmQrK10gPSBpO1xuICAgICAgICAgICAgY3VycmVudEJhbmRFbmQgPVxuICAgICAgICAgICAgICAgIChjdXJyZW50QmFuZCAqIGJhcmtTY2FsZVtub3JtYWxpc2VkU3BlY3RydW0ubGVuZ3RoIC0gMV0pIC9cbiAgICAgICAgICAgICAgICAgICAgTlVNX0JBUktfQkFORFM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmJMaW1pdHNbTlVNX0JBUktfQkFORFNdID0gbm9ybWFsaXNlZFNwZWN0cnVtLmxlbmd0aCAtIDE7XG4gICAgLy9wcm9jZXNzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOVU1fQkFSS19CQU5EUzsgaSsrKSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gYmJMaW1pdHNbaV07IGogPCBiYkxpbWl0c1tpICsgMV07IGorKykge1xuICAgICAgICAgICAgc3VtICs9IG5vcm1hbGlzZWRTcGVjdHJ1bVtqXTtcbiAgICAgICAgfVxuICAgICAgICBzcGVjaWZpY1tpXSA9IE1hdGgucG93KHN1bSwgMC4yMyk7XG4gICAgfVxuICAgIC8vZ2V0IHRvdGFsIGxvdWRuZXNzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpYy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbCArPSBzcGVjaWZpY1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3BlY2lmaWM6IHNwZWNpZmljLFxuICAgICAgICB0b3RhbDogdG90YWwsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGVyY2VwdHVhbFNwcmVhZCAoX2EpIHtcbiAgICB2YXIgYW1wU3BlY3RydW0gPSBfYS5hbXBTcGVjdHJ1bSwgYmFya1NjYWxlID0gX2EuYmFya1NjYWxlO1xuICAgIHZhciBsb3VkbmVzc1ZhbHVlID0gbG91ZG5lc3MoeyBhbXBTcGVjdHJ1bTogYW1wU3BlY3RydW0sIGJhcmtTY2FsZTogYmFya1NjYWxlIH0pO1xuICAgIHZhciBtYXggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG91ZG5lc3NWYWx1ZS5zcGVjaWZpYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobG91ZG5lc3NWYWx1ZS5zcGVjaWZpY1tpXSA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gbG91ZG5lc3NWYWx1ZS5zcGVjaWZpY1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3ByZWFkID0gTWF0aC5wb3coKGxvdWRuZXNzVmFsdWUudG90YWwgLSBtYXgpIC8gbG91ZG5lc3NWYWx1ZS50b3RhbCwgMik7XG4gICAgcmV0dXJuIHNwcmVhZDtcbn1cblxuZnVuY3Rpb24gcGVyY2VwdHVhbFNoYXJwbmVzcyAoX2EpIHtcbiAgICB2YXIgYW1wU3BlY3RydW0gPSBfYS5hbXBTcGVjdHJ1bSwgYmFya1NjYWxlID0gX2EuYmFya1NjYWxlO1xuICAgIHZhciBsb3VkbmVzc1ZhbHVlID0gbG91ZG5lc3MoeyBhbXBTcGVjdHJ1bTogYW1wU3BlY3RydW0sIGJhcmtTY2FsZTogYmFya1NjYWxlIH0pO1xuICAgIHZhciBzcGVjID0gbG91ZG5lc3NWYWx1ZS5zcGVjaWZpYztcbiAgICB2YXIgb3V0cHV0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPCAxNSkge1xuICAgICAgICAgICAgb3V0cHV0ICs9IChpICsgMSkgKiBzcGVjW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dCArPSAwLjA2NiAqIE1hdGguZXhwKDAuMTcxICogKGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3V0cHV0ICo9IDAuMTEgLyBsb3VkbmVzc1ZhbHVlLnRvdGFsO1xuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RQb3dlclNwZWN0cnVtIChfYSkge1xuICAgIHZhciBhbXBTcGVjdHJ1bSA9IF9hLmFtcFNwZWN0cnVtO1xuICAgIGlmICh0eXBlb2YgYW1wU3BlY3RydW0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgcG93ZXJTcGVjdHJ1bSA9IG5ldyBGbG9hdDMyQXJyYXkoYW1wU3BlY3RydW0ubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvd2VyU3BlY3RydW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG93ZXJTcGVjdHJ1bVtpXSA9IE1hdGgucG93KGFtcFNwZWN0cnVtW2ldLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvd2VyU3BlY3RydW07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RNZWxCYW5kcyAoX2EpIHtcbiAgICB2YXIgYW1wU3BlY3RydW0gPSBfYS5hbXBTcGVjdHJ1bSwgbWVsRmlsdGVyQmFuayA9IF9hLm1lbEZpbHRlckJhbmssIGJ1ZmZlclNpemUgPSBfYS5idWZmZXJTaXplO1xuICAgIGlmICh0eXBlb2YgYW1wU3BlY3RydW0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbGlkIGFtcFNwZWN0cnVtIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIG1lbEJhbmRzXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1lbEZpbHRlckJhbmsgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbGlkIG1lbEZpbHRlckJhbmsgaXMgcmVxdWlyZWQgdG8gZ2VuZXJhdGUgbWVsQmFuZHNcIik7XG4gICAgfVxuICAgIHZhciBwb3dTcGVjID0gZXh0cmFjdFBvd2VyU3BlY3RydW0oeyBhbXBTcGVjdHJ1bTogYW1wU3BlY3RydW0gfSk7XG4gICAgdmFyIG51bUZpbHRlcnMgPSBtZWxGaWx0ZXJCYW5rLmxlbmd0aDtcbiAgICB2YXIgZmlsdGVyZWQgPSBBcnJheShudW1GaWx0ZXJzKTtcbiAgICB2YXIgbG9nZ2VkTWVsQmFuZHMgPSBuZXcgRmxvYXQzMkFycmF5KG51bUZpbHRlcnMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nZ2VkTWVsQmFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmlsdGVyZWRbaV0gPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUgLyAyKTtcbiAgICAgICAgbG9nZ2VkTWVsQmFuZHNbaV0gPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJ1ZmZlclNpemUgLyAyOyBqKyspIHtcbiAgICAgICAgICAgIC8vcG9pbnQtd2lzZSBtdWx0aXBsaWNhdGlvbiBiZXR3ZWVuIHBvd2VyIHNwZWN0cnVtIGFuZCBmaWx0ZXJiYW5rcy5cbiAgICAgICAgICAgIGZpbHRlcmVkW2ldW2pdID0gbWVsRmlsdGVyQmFua1tpXVtqXSAqIHBvd1NwZWNbal07XG4gICAgICAgICAgICAvL3N1bW1pbmcgdXAgYWxsIG9mIHRoZSBjb2VmZmljaWVudHMgaW50byBvbmUgYXJyYXlcbiAgICAgICAgICAgIGxvZ2dlZE1lbEJhbmRzW2ldICs9IGZpbHRlcmVkW2ldW2pdO1xuICAgICAgICB9XG4gICAgICAgIC8vbG9nIGVhY2ggY29lZmZpY2llbnQuXG4gICAgICAgIGxvZ2dlZE1lbEJhbmRzW2ldID0gTWF0aC5sb2cobG9nZ2VkTWVsQmFuZHNbaV0gKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxvZ2dlZE1lbEJhbmRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qXFxcbiAqIERpc2NyZXRlIENvc2luZSBUcmFuc2Zvcm1cbiAqXG4gKiAoYykgVmFpbCBTeXN0ZW1zLiBKb3NodWEgSnVuZyBhbmQgQmVuIEJyeWFuLiAyMDE1XG4gKlxuICogVGhpcyBjb2RlIGlzIG5vdCBkZXNpZ25lZCB0byBiZSBoaWdobHkgb3B0aW1pemVkIGJ1dCBhcyBhbiBlZHVjYXRpb25hbFxuICogdG9vbCB0byB1bmRlcnN0YW5kIHRoZSBNZWwtc2NhbGUgYW5kIGl0cyByZWxhdGVkIGNvZWZmaWNpZW50cyB1c2VkIGluXG4gKiBodW1hbiBzcGVlY2ggYW5hbHlzaXMuXG5cXCo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG52YXIgY29zTWFwID0gbnVsbDtcblxuLy8gQnVpbGRzIGEgY29zaW5lIG1hcCBmb3IgdGhlIGdpdmVuIGlucHV0IHNpemUuIFRoaXMgYWxsb3dzIG11bHRpcGxlIGlucHV0IHNpemVzIHRvIGJlIG1lbW9pemVkIGF1dG9tYWdpY2FsbHlcbi8vIGlmIHlvdSB3YW50IHRvIHJ1biB0aGUgRENUIG92ZXIgYW5kIG92ZXIuXG52YXIgbWVtb2l6ZUNvc2luZXMgPSBmdW5jdGlvbihOKSB7XG4gIGNvc01hcCA9IGNvc01hcCB8fCB7fTtcbiAgY29zTWFwW05dID0gbmV3IEFycmF5KE4qTik7XG5cbiAgdmFyIFBJX04gPSBNYXRoLlBJIC8gTjtcblxuICBmb3IgKHZhciBrID0gMDsgayA8IE47IGsrKykge1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgTjsgbisrKSB7XG4gICAgICBjb3NNYXBbTl1bbiArIChrICogTildID0gTWF0aC5jb3MoUElfTiAqIChuICsgMC41KSAqIGspO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZGN0JDIoc2lnbmFsLCBzY2FsZSkge1xuICB2YXIgTCA9IHNpZ25hbC5sZW5ndGg7XG4gIHNjYWxlID0gc2NhbGUgfHwgMjtcblxuICBpZiAoIWNvc01hcCB8fCAhY29zTWFwW0xdKSBtZW1vaXplQ29zaW5lcyhMKTtcblxuICB2YXIgY29lZmZpY2llbnRzID0gc2lnbmFsLm1hcChmdW5jdGlvbiAoKSB7cmV0dXJuIDA7fSk7XG5cbiAgcmV0dXJuIGNvZWZmaWNpZW50cy5tYXAoZnVuY3Rpb24gKF9fLCBpeCkge1xuICAgIHJldHVybiBzY2FsZSAqIHNpZ25hbC5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1ciwgaXhfLCBhcnIpIHtcbiAgICAgIHJldHVybiBwcmV2ICsgKGN1ciAqIGNvc01hcFtMXVtpeF8gKyAoaXggKiBMKV0pO1xuICAgIH0sIDApO1xuICB9KTtcbn1cbnZhciBkY3RfMSA9IGRjdCQyO1xuXG52YXIgZGN0ID0gZGN0XzE7XG5cbnZhciBkY3QkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhkY3QpO1xuXG5mdW5jdGlvbiBtZmNjIChfYSkge1xuICAgIC8vIFR1dG9yaWFsIGZyb206XG4gICAgLy8gaHR0cDovL3ByYWN0aWNhbGNyeXB0b2dyYXBoeS5jb20vbWlzY2VsbGFuZW91cy9tYWNoaW5lLWxlYXJuaW5nXG4gICAgLy8gL2d1aWRlLW1lbC1mcmVxdWVuY3ktY2Vwc3RyYWwtY29lZmZpY2llbnRzLW1mY2NzL1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YXIgYW1wU3BlY3RydW0gPSBfYS5hbXBTcGVjdHJ1bSwgbWVsRmlsdGVyQmFuayA9IF9hLm1lbEZpbHRlckJhbmssIG51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyA9IF9hLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cywgYnVmZmVyU2l6ZSA9IF9hLmJ1ZmZlclNpemU7XG4gICAgdmFyIF9udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMgPSBNYXRoLm1pbig0MCwgTWF0aC5tYXgoMSwgbnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzIHx8IDEzKSk7XG4gICAgdmFyIG51bUZpbHRlcnMgPSBtZWxGaWx0ZXJCYW5rLmxlbmd0aDtcbiAgICBpZiAobnVtRmlsdGVycyA8IF9udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5zdWZmaWNpZW50IGZpbHRlciBiYW5rIGZvciByZXF1ZXN0ZWQgbnVtYmVyIG9mIGNvZWZmaWNpZW50c1wiKTtcbiAgICB9XG4gICAgdmFyIGxvZ2dlZE1lbEJhbmRzQXJyYXkgPSBleHRyYWN0TWVsQmFuZHMoe1xuICAgICAgICBhbXBTcGVjdHJ1bTogYW1wU3BlY3RydW0sXG4gICAgICAgIG1lbEZpbHRlckJhbms6IG1lbEZpbHRlckJhbmssXG4gICAgICAgIGJ1ZmZlclNpemU6IGJ1ZmZlclNpemUsXG4gICAgfSk7XG4gICAgdmFyIG1mY2NzID0gZGN0JDEobG9nZ2VkTWVsQmFuZHNBcnJheSkuc2xpY2UoMCwgX251bWJlck9mTUZDQ0NvZWZmaWNpZW50cyk7XG4gICAgcmV0dXJuIG1mY2NzO1xufVxuXG5mdW5jdGlvbiBjaHJvbWEgKF9hKSB7XG4gICAgdmFyIGFtcFNwZWN0cnVtID0gX2EuYW1wU3BlY3RydW0sIGNocm9tYUZpbHRlckJhbmsgPSBfYS5jaHJvbWFGaWx0ZXJCYW5rO1xuICAgIGlmICh0eXBlb2YgYW1wU3BlY3RydW0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbGlkIGFtcFNwZWN0cnVtIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIGNocm9tYVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaHJvbWFGaWx0ZXJCYW5rICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJWYWxpZCBjaHJvbWFGaWx0ZXJCYW5rIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIGNocm9tYVwiKTtcbiAgICB9XG4gICAgdmFyIGNocm9tYWdyYW0gPSBjaHJvbWFGaWx0ZXJCYW5rLm1hcChmdW5jdGlvbiAocm93LCBpKSB7XG4gICAgICAgIHJldHVybiBhbXBTcGVjdHJ1bS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdiwgaikgeyByZXR1cm4gYWNjICsgdiAqIHJvd1tqXTsgfSwgMCk7XG4gICAgfSk7XG4gICAgdmFyIG1heFZhbCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGNocm9tYWdyYW0pO1xuICAgIHJldHVybiBtYXhWYWwgPyBjaHJvbWFncmFtLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdiAvIG1heFZhbDsgfSkgOiBjaHJvbWFncmFtO1xufVxuXG4vLyBUaGlzIGZpbGUgaXNuJ3QgYmVpbmcgdHlwZWNoZWNrZWQgYXQgYWxsIGJlY2F1c2UgdGhlcmUgYXJlIG1ham9yIGlzc3VlcyB3aXRoIGl0LlxuLy8gU2VlICM4NTIgZm9yIGRldGFpbHMuIE9uY2UgdGhhdCdzIG1lcmdlZCwgdGhpcyBmaWxlIHNob3VsZCBiZSB0eXBlY2hlY2tlZC5cbi8vIEB0cy1ub2NoZWNrXG5mdW5jdGlvbiBzcGVjdHJhbEZsdXggKF9hKSB7XG4gICAgdmFyIHNpZ25hbCA9IF9hLnNpZ25hbCwgcHJldmlvdXNTaWduYWwgPSBfYS5wcmV2aW91c1NpZ25hbCwgYnVmZmVyU2l6ZSA9IF9hLmJ1ZmZlclNpemU7XG4gICAgaWYgKHR5cGVvZiBzaWduYWwgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHByZXZpb3VzU2lnbmFsICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgc2YgPSAwO1xuICAgIGZvciAodmFyIGkgPSAtKGJ1ZmZlclNpemUgLyAyKTsgaSA8IHNpZ25hbC5sZW5ndGggLyAyIC0gMTsgaSsrKSB7XG4gICAgICAgIHggPSBNYXRoLmFicyhzaWduYWxbaV0pIC0gTWF0aC5hYnMocHJldmlvdXNTaWduYWxbaV0pO1xuICAgICAgICBzZiArPSAoeCArIE1hdGguYWJzKHgpKSAvIDI7XG4gICAgfVxuICAgIHJldHVybiBzZjtcbn1cblxuZnVuY3Rpb24gc3BlY3RyYWxDcmVzdCAoX2EpIHtcbiAgICB2YXIgYW1wU3BlY3RydW0gPSBfYS5hbXBTcGVjdHJ1bTtcbiAgICBpZiAodHlwZW9mIGFtcFNwZWN0cnVtICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIHJtcyA9IDA7XG4gICAgdmFyIHBlYWsgPSAtSW5maW5pdHk7XG4gICAgYW1wU3BlY3RydW0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBybXMgKz0gTWF0aC5wb3coeCwgMik7XG4gICAgICAgIHBlYWsgPSB4ID4gcGVhayA/IHggOiBwZWFrO1xuICAgIH0pO1xuICAgIHJtcyA9IHJtcyAvIGFtcFNwZWN0cnVtLmxlbmd0aDtcbiAgICBybXMgPSBNYXRoLnNxcnQocm1zKTtcbiAgICByZXR1cm4gcGVhayAvIHJtcztcbn1cblxudmFyIGJ1ZmZlciA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3Muc2lnbmFsO1xufTtcbnZhciBjb21wbGV4U3BlY3RydW0gPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiBhcmdzLmNvbXBsZXhTcGVjdHJ1bTtcbn07XG52YXIgYW1wbGl0dWRlU3BlY3RydW0gPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiBhcmdzLmFtcFNwZWN0cnVtO1xufTtcblxudmFyIGV4dHJhY3RvcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGFtcGxpdHVkZVNwZWN0cnVtOiBhbXBsaXR1ZGVTcGVjdHJ1bSxcbiAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICBjaHJvbWE6IGNocm9tYSxcbiAgICBjb21wbGV4U3BlY3RydW06IGNvbXBsZXhTcGVjdHJ1bSxcbiAgICBlbmVyZ3k6IGVuZXJneSxcbiAgICBsb3VkbmVzczogbG91ZG5lc3MsXG4gICAgbWVsQmFuZHM6IGV4dHJhY3RNZWxCYW5kcyxcbiAgICBtZmNjOiBtZmNjLFxuICAgIHBlcmNlcHR1YWxTaGFycG5lc3M6IHBlcmNlcHR1YWxTaGFycG5lc3MsXG4gICAgcGVyY2VwdHVhbFNwcmVhZDogcGVyY2VwdHVhbFNwcmVhZCxcbiAgICBwb3dlclNwZWN0cnVtOiBleHRyYWN0UG93ZXJTcGVjdHJ1bSxcbiAgICBybXM6IHJtcyxcbiAgICBzcGVjdHJhbENlbnRyb2lkOiBzcGVjdHJhbENlbnRyb2lkLFxuICAgIHNwZWN0cmFsQ3Jlc3Q6IHNwZWN0cmFsQ3Jlc3QsXG4gICAgc3BlY3RyYWxGbGF0bmVzczogc3BlY3RyYWxGbGF0bmVzcyxcbiAgICBzcGVjdHJhbEZsdXg6IHNwZWN0cmFsRmx1eCxcbiAgICBzcGVjdHJhbEt1cnRvc2lzOiBzcGVjdHJhbEt1cnRvc2lzLFxuICAgIHNwZWN0cmFsUm9sbG9mZjogc3BlY3RyYWxSb2xsb2ZmLFxuICAgIHNwZWN0cmFsU2tld25lc3M6IHNwZWN0cmFsU2tld25lc3MsXG4gICAgc3BlY3RyYWxTbG9wZTogc3BlY3RyYWxTbG9wZSxcbiAgICBzcGVjdHJhbFNwcmVhZDogc3BlY3RyYWxTcHJlYWQsXG4gICAgemNyOiB6Y3Jcbn0pO1xuXG4vLyBtZW1vaXphdGlvbiBvZiB0aGUgcmV2ZXJzYWwgb2YgZGlmZmVyZW50IGxlbmd0aHMuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgbWVtb2l6ZWRSZXZlcnNhbCA9IHt9O1xudmFyIG1lbW9pemVkWmVyb0J1ZmZlcnMgPSB7fTtcblxudmFyIGNvbnN0cnVjdENvbXBsZXhBcnJheSA9IGZ1bmN0aW9uIGNvbnN0cnVjdENvbXBsZXhBcnJheShzaWduYWwpIHtcbiAgdmFyIGNvbXBsZXhTaWduYWwgPSB7fTtcblxuICBjb21wbGV4U2lnbmFsLnJlYWwgPSBzaWduYWwucmVhbCA9PT0gdW5kZWZpbmVkID8gc2lnbmFsLnNsaWNlKCkgOiBzaWduYWwucmVhbC5zbGljZSgpO1xuXG4gIHZhciBidWZmZXJTaXplID0gY29tcGxleFNpZ25hbC5yZWFsLmxlbmd0aDtcblxuICBpZiAobWVtb2l6ZWRaZXJvQnVmZmVyc1tidWZmZXJTaXplXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWVtb2l6ZWRaZXJvQnVmZmVyc1tidWZmZXJTaXplXSA9IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KGJ1ZmZlclNpemUpKS5tYXAoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLCAwKTtcbiAgfVxuXG4gIGNvbXBsZXhTaWduYWwuaW1hZyA9IG1lbW9pemVkWmVyb0J1ZmZlcnNbYnVmZmVyU2l6ZV0uc2xpY2UoKTtcblxuICByZXR1cm4gY29tcGxleFNpZ25hbDtcbn07XG5cbnZhciBiaXRSZXZlcnNlQXJyYXkgPSBmdW5jdGlvbiBiaXRSZXZlcnNlQXJyYXkoTikge1xuICBpZiAobWVtb2l6ZWRSZXZlcnNhbFtOXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG1heEJpbmFyeUxlbmd0aCA9IChOIC0gMSkudG9TdHJpbmcoMikubGVuZ3RoOyAvL2dldCB0aGUgYmluYXJ5IGxlbmd0aCBvZiB0aGUgbGFyZ2VzdCBpbmRleC5cbiAgICB2YXIgdGVtcGxhdGVCaW5hcnkgPSAnMCcucmVwZWF0KG1heEJpbmFyeUxlbmd0aCk7IC8vY3JlYXRlIGEgdGVtcGxhdGUgYmluYXJ5IG9mIHRoYXQgbGVuZ3RoLlxuICAgIHZhciByZXZlcnNlZCA9IHt9O1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgTjsgbisrKSB7XG4gICAgICB2YXIgY3VyckJpbmFyeSA9IG4udG9TdHJpbmcoMik7IC8vZ2V0IGJpbmFyeSB2YWx1ZSBvZiBjdXJyZW50IGluZGV4LlxuXG4gICAgICAvL3ByZXBlbmQgemVyb3MgZnJvbSB0ZW1wbGF0ZSB0byBjdXJyZW50IGJpbmFyeS4gVGhpcyBtYWtlcyBiaW5hcnkgdmFsdWVzIG9mIGFsbCBpbmRpY2VzIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICAgICAgY3VyckJpbmFyeSA9IHRlbXBsYXRlQmluYXJ5LnN1YnN0cihjdXJyQmluYXJ5Lmxlbmd0aCkgKyBjdXJyQmluYXJ5O1xuXG4gICAgICBjdXJyQmluYXJ5ID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjdXJyQmluYXJ5KSkucmV2ZXJzZSgpLmpvaW4oJycpOyAvL3JldmVyc2VcbiAgICAgIHJldmVyc2VkW25dID0gcGFyc2VJbnQoY3VyckJpbmFyeSwgMik7IC8vY29udmVydCB0byBkZWNpbWFsXG4gICAgfVxuICAgIG1lbW9pemVkUmV2ZXJzYWxbTl0gPSByZXZlcnNlZDsgLy9zYXZlXG4gIH1cbiAgcmV0dXJuIG1lbW9pemVkUmV2ZXJzYWxbTl07XG59O1xuXG4vLyBjb21wbGV4IG11bHRpcGxpY2F0aW9uXG52YXIgbXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShhLCBiKSB7XG4gIHJldHVybiB7XG4gICAgJ3JlYWwnOiBhLnJlYWwgKiBiLnJlYWwgLSBhLmltYWcgKiBiLmltYWcsXG4gICAgJ2ltYWcnOiBhLnJlYWwgKiBiLmltYWcgKyBhLmltYWcgKiBiLnJlYWxcbiAgfTtcbn07XG5cbi8vIGNvbXBsZXggYWRkaXRpb25cbnZhciBhZGQgPSBmdW5jdGlvbiBhZGQoYSwgYikge1xuICByZXR1cm4ge1xuICAgICdyZWFsJzogYS5yZWFsICsgYi5yZWFsLFxuICAgICdpbWFnJzogYS5pbWFnICsgYi5pbWFnXG4gIH07XG59O1xuXG4vLyBjb21wbGV4IHN1YnRyYWN0aW9uXG52YXIgc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiKSB7XG4gIHJldHVybiB7XG4gICAgJ3JlYWwnOiBhLnJlYWwgLSBiLnJlYWwsXG4gICAgJ2ltYWcnOiBhLmltYWcgLSBiLmltYWdcbiAgfTtcbn07XG5cbi8vIGV1bGVyJ3MgaWRlbnRpdHkgZV54ID0gY29zKHgpICsgc2luKHgpXG52YXIgZXVsZXIgPSBmdW5jdGlvbiBldWxlcihrbiwgTikge1xuICB2YXIgeCA9IC0yICogTWF0aC5QSSAqIGtuIC8gTjtcbiAgcmV0dXJuIHsgJ3JlYWwnOiBNYXRoLmNvcyh4KSwgJ2ltYWcnOiBNYXRoLnNpbih4KSB9O1xufTtcblxuLy8gY29tcGxleCBjb25qdWdhdGVcbnZhciBjb25qID0gZnVuY3Rpb24gY29uaihhKSB7XG4gIGEuaW1hZyAqPSAtMTtcbiAgcmV0dXJuIGE7XG59O1xuXG52YXIgdXRpbHMkMSA9IHtcbiAgYml0UmV2ZXJzZUFycmF5OiBiaXRSZXZlcnNlQXJyYXksXG4gIG11bHRpcGx5OiBtdWx0aXBseSxcbiAgYWRkOiBhZGQsXG4gIHN1YnRyYWN0OiBzdWJ0cmFjdCxcbiAgZXVsZXI6IGV1bGVyLFxuICBjb25qOiBjb25qLFxuICBjb25zdHJ1Y3RDb21wbGV4QXJyYXk6IGNvbnN0cnVjdENvbXBsZXhBcnJheVxufTtcblxudmFyIHV0aWxzID0gdXRpbHMkMTtcblxuLy8gcmVhbCB0byBjb21wbGV4IGZmdFxudmFyIGZmdCA9IGZ1bmN0aW9uIGZmdChzaWduYWwpIHtcblxuICB2YXIgY29tcGxleFNpZ25hbCA9IHt9O1xuXG4gIGlmIChzaWduYWwucmVhbCA9PT0gdW5kZWZpbmVkIHx8IHNpZ25hbC5pbWFnID09PSB1bmRlZmluZWQpIHtcbiAgICBjb21wbGV4U2lnbmFsID0gdXRpbHMuY29uc3RydWN0Q29tcGxleEFycmF5KHNpZ25hbCk7XG4gIH0gZWxzZSB7XG4gICAgY29tcGxleFNpZ25hbC5yZWFsID0gc2lnbmFsLnJlYWwuc2xpY2UoKTtcbiAgICBjb21wbGV4U2lnbmFsLmltYWcgPSBzaWduYWwuaW1hZy5zbGljZSgpO1xuICB9XG5cbiAgdmFyIE4gPSBjb21wbGV4U2lnbmFsLnJlYWwubGVuZ3RoO1xuICB2YXIgbG9nTiA9IE1hdGgubG9nMihOKTtcblxuICBpZiAoTWF0aC5yb3VuZChsb2dOKSAhPSBsb2dOKSB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIDIuJyk7XG5cbiAgaWYgKGNvbXBsZXhTaWduYWwucmVhbC5sZW5ndGggIT0gY29tcGxleFNpZ25hbC5pbWFnLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVhbCBhbmQgaW1hZ2luYXJ5IGNvbXBvbmVudHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aC4nKTtcbiAgfVxuXG4gIHZhciBiaXRSZXZlcnNlZEluZGljZXMgPSB1dGlscy5iaXRSZXZlcnNlQXJyYXkoTik7XG5cbiAgLy8gc29ydCBhcnJheVxuICB2YXIgb3JkZXJlZCA9IHtcbiAgICAncmVhbCc6IFtdLFxuICAgICdpbWFnJzogW11cbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgIG9yZGVyZWQucmVhbFtiaXRSZXZlcnNlZEluZGljZXNbaV1dID0gY29tcGxleFNpZ25hbC5yZWFsW2ldO1xuICAgIG9yZGVyZWQuaW1hZ1tiaXRSZXZlcnNlZEluZGljZXNbaV1dID0gY29tcGxleFNpZ25hbC5pbWFnW2ldO1xuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IE47IF9pKyspIHtcbiAgICBjb21wbGV4U2lnbmFsLnJlYWxbX2ldID0gb3JkZXJlZC5yZWFsW19pXTtcbiAgICBjb21wbGV4U2lnbmFsLmltYWdbX2ldID0gb3JkZXJlZC5pbWFnW19pXTtcbiAgfVxuICAvLyBpdGVyYXRlIG92ZXIgdGhlIG51bWJlciBvZiBzdGFnZXNcbiAgZm9yICh2YXIgbiA9IDE7IG4gPD0gbG9nTjsgbisrKSB7XG4gICAgdmFyIGN1cnJOID0gTWF0aC5wb3coMiwgbik7XG5cbiAgICAvLyBmaW5kIHR3aWRkbGUgZmFjdG9yc1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY3Vyck4gLyAyOyBrKyspIHtcbiAgICAgIHZhciB0d2lkZGxlID0gdXRpbHMuZXVsZXIoaywgY3Vyck4pO1xuXG4gICAgICAvLyBvbiBlYWNoIGJsb2NrIG9mIEZULCBpbXBsZW1lbnQgdGhlIGJ1dHRlcmZseSBkaWFncmFtXG4gICAgICBmb3IgKHZhciBtID0gMDsgbSA8IE4gLyBjdXJyTjsgbSsrKSB7XG4gICAgICAgIHZhciBjdXJyRXZlbkluZGV4ID0gY3Vyck4gKiBtICsgaztcbiAgICAgICAgdmFyIGN1cnJPZGRJbmRleCA9IGN1cnJOICogbSArIGsgKyBjdXJyTiAvIDI7XG5cbiAgICAgICAgdmFyIGN1cnJFdmVuSW5kZXhTYW1wbGUgPSB7XG4gICAgICAgICAgJ3JlYWwnOiBjb21wbGV4U2lnbmFsLnJlYWxbY3VyckV2ZW5JbmRleF0sXG4gICAgICAgICAgJ2ltYWcnOiBjb21wbGV4U2lnbmFsLmltYWdbY3VyckV2ZW5JbmRleF1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGN1cnJPZGRJbmRleFNhbXBsZSA9IHtcbiAgICAgICAgICAncmVhbCc6IGNvbXBsZXhTaWduYWwucmVhbFtjdXJyT2RkSW5kZXhdLFxuICAgICAgICAgICdpbWFnJzogY29tcGxleFNpZ25hbC5pbWFnW2N1cnJPZGRJbmRleF1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb2RkID0gdXRpbHMubXVsdGlwbHkodHdpZGRsZSwgY3Vyck9kZEluZGV4U2FtcGxlKTtcblxuICAgICAgICB2YXIgc3VidHJhY3Rpb25SZXN1bHQgPSB1dGlscy5zdWJ0cmFjdChjdXJyRXZlbkluZGV4U2FtcGxlLCBvZGQpO1xuICAgICAgICBjb21wbGV4U2lnbmFsLnJlYWxbY3Vyck9kZEluZGV4XSA9IHN1YnRyYWN0aW9uUmVzdWx0LnJlYWw7XG4gICAgICAgIGNvbXBsZXhTaWduYWwuaW1hZ1tjdXJyT2RkSW5kZXhdID0gc3VidHJhY3Rpb25SZXN1bHQuaW1hZztcblxuICAgICAgICB2YXIgYWRkaXRpb25SZXN1bHQgPSB1dGlscy5hZGQob2RkLCBjdXJyRXZlbkluZGV4U2FtcGxlKTtcbiAgICAgICAgY29tcGxleFNpZ25hbC5yZWFsW2N1cnJFdmVuSW5kZXhdID0gYWRkaXRpb25SZXN1bHQucmVhbDtcbiAgICAgICAgY29tcGxleFNpZ25hbC5pbWFnW2N1cnJFdmVuSW5kZXhdID0gYWRkaXRpb25SZXN1bHQuaW1hZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29tcGxleFNpZ25hbDtcbn07XG5cbi8vIGNvbXBsZXggdG8gcmVhbCBpZmZ0XG52YXIgaWZmdCA9IGZ1bmN0aW9uIGlmZnQoc2lnbmFsKSB7XG5cbiAgaWYgKHNpZ25hbC5yZWFsID09PSB1bmRlZmluZWQgfHwgc2lnbmFsLmltYWcgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIklGRlQgb25seSBhY2NlcHRzIGEgY29tcGxleCBpbnB1dC5cIik7XG4gIH1cblxuICB2YXIgTiA9IHNpZ25hbC5yZWFsLmxlbmd0aDtcblxuICB2YXIgY29tcGxleFNpZ25hbCA9IHtcbiAgICAncmVhbCc6IFtdLFxuICAgICdpbWFnJzogW11cbiAgfTtcblxuICAvL3Rha2UgY29tcGxleCBjb25qdWdhdGUgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byB1c2UgdGhlIHJlZ3VsYXIgRkZUIGZvciBJRkZUXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRTYW1wbGUgPSB7XG4gICAgICAncmVhbCc6IHNpZ25hbC5yZWFsW2ldLFxuICAgICAgJ2ltYWcnOiBzaWduYWwuaW1hZ1tpXVxuICAgIH07XG5cbiAgICB2YXIgY29uanVnYXRlU2FtcGxlID0gdXRpbHMuY29uaihjdXJyZW50U2FtcGxlKTtcbiAgICBjb21wbGV4U2lnbmFsLnJlYWxbaV0gPSBjb25qdWdhdGVTYW1wbGUucmVhbDtcbiAgICBjb21wbGV4U2lnbmFsLmltYWdbaV0gPSBjb25qdWdhdGVTYW1wbGUuaW1hZztcbiAgfVxuXG4gIC8vY29tcHV0ZVxuICB2YXIgWCA9IGZmdChjb21wbGV4U2lnbmFsKTtcblxuICAvL25vcm1hbGl6ZVxuICBjb21wbGV4U2lnbmFsLnJlYWwgPSBYLnJlYWwubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsIC8gTjtcbiAgfSk7XG5cbiAgY29tcGxleFNpZ25hbC5pbWFnID0gWC5pbWFnLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbCAvIE47XG4gIH0pO1xuXG4gIHJldHVybiBjb21wbGV4U2lnbmFsO1xufTtcblxudmFyIGZmdF8xID0ge1xuICBmZnQ6IGZmdCxcbiAgaWZmdDogaWZmdFxufTtcblxuLyoqXG4gKiBNZXlkYSdzIGludGVyZmFjZSB0byB0aGUgV2ViIEF1ZGlvIEFQSS4gTWV5ZGFBbmFseXplciBhYnN0cmFjdHMgYW4gQVBJIG9uXG4gKiB0b3Agb2YgdGhlIFdlYiBBdWRpbyBBUEkncyBTY3JpcHRQcm9jZXNzb3JOb2RlLCBydW5uaW5nIHRoZSBNZXlkYSBhdWRpb1xuICogZmVhdHVyZSBleHRyYWN0b3JzIGluc2lkZSB0aGF0IGNvbnRleHQuXG4gKlxuICogTWV5ZGFBbmFseXplcidzIGNvbnN0cnVjdG9yIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5IC0gTWV5ZGFBbmFseXplclxuICogb2JqZWN0cyBzaG91bGQgYmUgZ2VuZXJhdGVkIHVzaW5nIHRoZSB7QGxpbmsgY3JlYXRlTWV5ZGFBbmFseXplcn1cbiAqIGZhY3RvcnkgZnVuY3Rpb24gaW4gdGhlIG1haW4gTWV5ZGEgY2xhc3MuXG4gKlxuICogT3B0aW9ucyBhcmUgb2YgdHlwZSB7QGxpbmsgTWV5ZGFBbmFseXplck9wdGlvbnN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhbmFseXplciA9IE1leWRhLmNyZWF0ZU1leWRhQW5hbHl6ZXIoe1xuICogICBcImF1ZGlvQ29udGV4dFwiOiBhdWRpb0NvbnRleHQsXG4gKiAgIFwic291cmNlXCI6IHNvdXJjZSxcbiAqICAgXCJidWZmZXJTaXplXCI6IDUxMixcbiAqICAgXCJmZWF0dXJlRXh0cmFjdG9yc1wiOiBbXCJybXNcIl0sXG4gKiAgIFwiaW5wdXRzXCI6IDIsXG4gKiAgIFwibnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzXCI6IDIwXG4gKiAgIFwiY2FsbGJhY2tcIjogZmVhdHVyZXMgPT4ge1xuICogICAgIGxldmVsUmFuZ2VFbGVtZW50LnZhbHVlID0gZmVhdHVyZXMucm1zO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICovXG52YXIgTWV5ZGFBbmFseXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIE1leWRhQW5hbHl6ZXIob3B0aW9ucywgX3RoaXMpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICB0aGlzLl9tID0gX3RoaXM7XG4gICAgICAgIGlmICghb3B0aW9ucy5hdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX20uZXJyb3JzLm5vQUM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5idWZmZXJTaXplICYmXG4gICAgICAgICAgICAhaXNQb3dlck9mVHdvKG9wdGlvbnMuYnVmZmVyU2l6ZSkpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX20uX2Vycm9ycy5ub3RQb3cyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFvcHRpb25zLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fbS5fZXJyb3JzLm5vU291cmNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX20uYXVkaW9Db250ZXh0ID0gb3B0aW9ucy5hdWRpb0NvbnRleHQ7XG4gICAgICAgIC8vIFRPRE86IHZhbGlkYXRlIG9wdGlvbnNcbiAgICAgICAgdGhpcy5fbS5idWZmZXJTaXplID0gb3B0aW9ucy5idWZmZXJTaXplIHx8IHRoaXMuX20uYnVmZmVyU2l6ZSB8fCAyNTY7XG4gICAgICAgIHRoaXMuX20uaG9wU2l6ZSA9IG9wdGlvbnMuaG9wU2l6ZSB8fCB0aGlzLl9tLmhvcFNpemUgfHwgdGhpcy5fbS5idWZmZXJTaXplO1xuICAgICAgICB0aGlzLl9tLnNhbXBsZVJhdGUgPVxuICAgICAgICAgICAgb3B0aW9ucy5zYW1wbGVSYXRlIHx8IHRoaXMuX20uYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgfHwgNDQxMDA7XG4gICAgICAgIHRoaXMuX20uY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgICAgICB0aGlzLl9tLndpbmRvd2luZ0Z1bmN0aW9uID0gb3B0aW9ucy53aW5kb3dpbmdGdW5jdGlvbiB8fCBcImhhbm5pbmdcIjtcbiAgICAgICAgdGhpcy5fbS5mZWF0dXJlRXh0cmFjdG9ycyA9IGV4dHJhY3RvcnM7XG4gICAgICAgIHRoaXMuX20uRVhUUkFDVElPTl9TVEFSVEVEID0gb3B0aW9ucy5zdGFydEltbWVkaWF0ZWx5IHx8IGZhbHNlO1xuICAgICAgICB0aGlzLl9tLmNoYW5uZWwgPSB0eXBlb2Ygb3B0aW9ucy5jaGFubmVsID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5jaGFubmVsIDogMDtcbiAgICAgICAgdGhpcy5fbS5pbnB1dHMgPSBvcHRpb25zLmlucHV0cyB8fCAxO1xuICAgICAgICB0aGlzLl9tLm91dHB1dHMgPSBvcHRpb25zLm91dHB1dHMgfHwgMTtcbiAgICAgICAgdGhpcy5fbS5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMgPVxuICAgICAgICAgICAgb3B0aW9ucy5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9tLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyB8fFxuICAgICAgICAgICAgICAgIDEzO1xuICAgICAgICB0aGlzLl9tLm51bWJlck9mQmFya0JhbmRzID1cbiAgICAgICAgICAgIG9wdGlvbnMubnVtYmVyT2ZCYXJrQmFuZHMgfHwgdGhpcy5fbS5udW1iZXJPZkJhcmtCYW5kcyB8fCAyNDtcbiAgICAgICAgLy9jcmVhdGUgbm9kZXNcbiAgICAgICAgdGhpcy5fbS5zcG4gPSB0aGlzLl9tLmF1ZGlvQ29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IodGhpcy5fbS5idWZmZXJTaXplLCB0aGlzLl9tLmlucHV0cywgdGhpcy5fbS5vdXRwdXRzKTtcbiAgICAgICAgdGhpcy5fbS5zcG4uY29ubmVjdCh0aGlzLl9tLmF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuX20uX2ZlYXR1cmVzVG9FeHRyYWN0ID0gb3B0aW9ucy5mZWF0dXJlRXh0cmFjdG9ycyB8fCBbXTtcbiAgICAgICAgLy9hbHdheXMgcmVjYWxjdWxhdGUgQlMgYW5kIE1GQiB3aGVuIGEgbmV3IE1leWRhIGFuYWx5emVyIGlzIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX20uYmFya1NjYWxlID0gY3JlYXRlQmFya1NjYWxlKHRoaXMuX20uYnVmZmVyU2l6ZSwgdGhpcy5fbS5zYW1wbGVSYXRlLCB0aGlzLl9tLmJ1ZmZlclNpemUpO1xuICAgICAgICB0aGlzLl9tLm1lbEZpbHRlckJhbmsgPSBjcmVhdGVNZWxGaWx0ZXJCYW5rKE1hdGgubWF4KHRoaXMuX20ubWVsQmFuZHMsIHRoaXMuX20ubnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzKSwgdGhpcy5fbS5zYW1wbGVSYXRlLCB0aGlzLl9tLmJ1ZmZlclNpemUpO1xuICAgICAgICB0aGlzLl9tLmlucHV0RGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX20ucHJldmlvdXNJbnB1dERhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl9tLmZyYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbS5wcmV2aW91c0ZyYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2Uob3B0aW9ucy5zb3VyY2UpO1xuICAgICAgICB0aGlzLl9tLnNwbi5vbmF1ZGlvcHJvY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyO1xuICAgICAgICAgICAgaWYgKF90aGlzXzEuX20uaW5wdXREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXNfMS5fbS5wcmV2aW91c0lucHV0RGF0YSA9IF90aGlzXzEuX20uaW5wdXREYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXNfMS5fbS5pbnB1dERhdGEgPSBlLmlucHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKF90aGlzXzEuX20uY2hhbm5lbCk7XG4gICAgICAgICAgICBpZiAoIV90aGlzXzEuX20ucHJldmlvdXNJbnB1dERhdGEpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBfdGhpc18xLl9tLmlucHV0RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXNfMS5fbS5wcmV2aW91c0lucHV0RGF0YS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICBfdGhpc18xLl9tLmlucHV0RGF0YS5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgICBfdGhpc18xLl9tLmhvcFNpemUpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXQoX3RoaXNfMS5fbS5wcmV2aW91c0lucHV0RGF0YS5zbGljZShfdGhpc18xLl9tLmhvcFNpemUpKTtcbiAgICAgICAgICAgICAgICBidWZmZXIuc2V0KF90aGlzXzEuX20uaW5wdXREYXRhLCBfdGhpc18xLl9tLnByZXZpb3VzSW5wdXREYXRhLmxlbmd0aCAtIF90aGlzXzEuX20uaG9wU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZnJhbWVzID0gZnJhbWUoYnVmZmVyLCBfdGhpc18xLl9tLmJ1ZmZlclNpemUsIF90aGlzXzEuX20uaG9wU2l6ZSk7XG4gICAgICAgICAgICBmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgIF90aGlzXzEuX20uZnJhbWUgPSBmO1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IF90aGlzXzEuX20uZXh0cmFjdChfdGhpc18xLl9tLl9mZWF0dXJlc1RvRXh0cmFjdCwgX3RoaXNfMS5fbS5mcmFtZSwgX3RoaXNfMS5fbS5wcmV2aW91c0ZyYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGNhbGxiYWNrIGlmIGFwcGxpY2FibGVcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzXzEuX20uY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpc18xLl9tLkVYVFJBQ1RJT05fU1RBUlRFRCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpc18xLl9tLmNhbGxiYWNrKGZlYXR1cmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXNfMS5fbS5wcmV2aW91c0ZyYW1lID0gX3RoaXNfMS5fbS5mcmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBmZWF0dXJlIGV4dHJhY3Rpb25cbiAgICAgKiBUaGUgYXVkaW8gZmVhdHVyZXMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2FzIGRlZmluZWRcbiAgICAgKiBpbiB0aGUgTWV5ZGFPcHRpb25zIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIGZhY3Rvcnkgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlXG4gICAgICogTWV5ZGFBbmFseXplci5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8QXJyYXkuPHN0cmluZz4pfSBbZmVhdHVyZXNdXG4gICAgICogQ2hhbmdlIHRoZSBmZWF0dXJlcyB0aGF0IE1leWRhIGlzIGV4dHJhY3RpbmcuIERlZmF1bHRzIHRvIHRoZSBmZWF0dXJlcyB0aGF0XG4gICAgICogd2VyZSBzZXQgdXBvbiBjb25zdHJ1Y3Rpb24gaW4gdGhlIG9wdGlvbnMgcGFyYW1ldGVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGFuYWx5emVyLnN0YXJ0KCdjaHJvbWEnKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBNZXlkYUFuYWx5emVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChmZWF0dXJlcykge1xuICAgICAgICB0aGlzLl9tLl9mZWF0dXJlc1RvRXh0cmFjdCA9IGZlYXR1cmVzIHx8IHRoaXMuX20uX2ZlYXR1cmVzVG9FeHRyYWN0O1xuICAgICAgICB0aGlzLl9tLkVYVFJBQ1RJT05fU1RBUlRFRCA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9wIGZlYXR1cmUgZXh0cmFjdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBhbmFseXplci5zdG9wKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgTWV5ZGFBbmFseXplci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbS5FWFRSQUNUSU9OX1NUQVJURUQgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgQXVkaW8gTm9kZSBmb3IgTWV5ZGEgdG8gbGlzdGVuIHRvLlxuICAgICAqIEBwYXJhbSB7QXVkaW9Ob2RlfSBzb3VyY2UgLSBUaGUgQXVkaW8gTm9kZSBmb3IgTWV5ZGEgdG8gbGlzdGVuIHRvXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogYW5hbHl6ZXIuc2V0U291cmNlKGF1ZGlvU291cmNlTm9kZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgTWV5ZGFBbmFseXplci5wcm90b3R5cGUuc2V0U291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICB0aGlzLl9tLnNvdXJjZSAmJiB0aGlzLl9tLnNvdXJjZS5kaXNjb25uZWN0KHRoaXMuX20uc3BuKTtcbiAgICAgICAgdGhpcy5fbS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuX20uc291cmNlLmNvbm5lY3QodGhpcy5fbS5zcG4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjaGFubmVsIG9mIHRoZSBhdWRpbyBub2RlIGZvciBNZXlkYSB0byBsaXN0ZW4gdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbCAtIHRoZSBpbmRleCBvZiB0aGUgY2hhbm5lbCBvbiB0aGUgaW5wdXQgYXVkaW8gbm9kZVxuICAgICAqIGZvciBNZXlkYSB0byBsaXN0ZW4gdG8uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogYW5hbHl6ZXIuc2V0Q2hhbm5lbCgwKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBNZXlkYUFuYWx5emVyLnByb3RvdHlwZS5zZXRDaGFubmVsID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgaWYgKGNoYW5uZWwgPD0gdGhpcy5fbS5pbnB1dHMpIHtcbiAgICAgICAgICAgIHRoaXMuX20uY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2hhbm5lbCBcIi5jb25jYXQoY2hhbm5lbCwgXCIgZG9lcyBub3QgZXhpc3QuIE1ha2Ugc3VyZSB5b3UndmUgcHJvdmlkZWQgYSB2YWx1ZSBmb3IgJ2lucHV0cycgdGhhdCBpcyBncmVhdGVyIHRoYW4gXCIpLmNvbmNhdChjaGFubmVsLCBcIiB3aGVuIGluc3RhbnRpYXRpbmcgdGhlIE1leWRhQW5hbHl6ZXJcIikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgYSBzZXQgb2YgZmVhdHVyZXMgZnJvbSB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8QXJyYXkuPHN0cmluZz4pfSBbZmVhdHVyZXNdXG4gICAgICogQ2hhbmdlIHRoZSBmZWF0dXJlcyB0aGF0IE1leWRhIGlzIGV4dHJhY3RpbmdcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBhbmFseXplci5nZXQoJ3NwZWN0cmFsRmxhdG5lc3MnKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBNZXlkYUFuYWx5emVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZmVhdHVyZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX20uaW5wdXREYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbS5leHRyYWN0KGZlYXR1cmVzIHx8IHRoaXMuX20uX2ZlYXR1cmVzVG9FeHRyYWN0LCB0aGlzLl9tLmlucHV0RGF0YSwgdGhpcy5fbS5wcmV2aW91c0lucHV0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1leWRhQW5hbHl6ZXI7XG59KCkpO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgZGVmYXVsdCBleHBvcnQgZm9yIE1leWRhLCB5b3UgcHJvYmFibHkgd2FudCB0byBjaGVja1xuICogb3V0IHtAbGluayBkZWZhdWx0fVxuICpcbiAqIEBtb2R1bGUgTWV5ZGFcbiAqL1xudmFyIE1leWRhID0ge1xuICAgIGF1ZGlvQ29udGV4dDogbnVsbCxcbiAgICBzcG46IG51bGwsXG4gICAgYnVmZmVyU2l6ZTogNTEyLFxuICAgIHNhbXBsZVJhdGU6IDQ0MTAwLFxuICAgIG1lbEJhbmRzOiAyNixcbiAgICBjaHJvbWFCYW5kczogMTIsXG4gICAgY2FsbGJhY2s6IG51bGwsXG4gICAgd2luZG93aW5nRnVuY3Rpb246IFwiaGFubmluZ1wiLFxuICAgIGZlYXR1cmVFeHRyYWN0b3JzOiBleHRyYWN0b3JzLFxuICAgIEVYVFJBQ1RJT05fU1RBUlRFRDogZmFsc2UsXG4gICAgbnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzOiAxMyxcbiAgICBudW1iZXJPZkJhcmtCYW5kczogMjQsXG4gICAgX2ZlYXR1cmVzVG9FeHRyYWN0OiBbXSxcbiAgICB3aW5kb3dpbmc6IGFwcGx5V2luZG93LFxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgX2Vycm9yczoge1xuICAgICAgICBub3RQb3cyOiBuZXcgRXJyb3IoXCJNZXlkYTogQnVmZmVyIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIDIsIGUuZy4gNjQgb3IgNTEyXCIpLFxuICAgICAgICBmZWF0dXJlVW5kZWY6IG5ldyBFcnJvcihcIk1leWRhOiBObyBmZWF0dXJlcyBkZWZpbmVkLlwiKSxcbiAgICAgICAgaW52YWxpZEZlYXR1cmVGbXQ6IG5ldyBFcnJvcihcIk1leWRhOiBJbnZhbGlkIGZlYXR1cmUgZm9ybWF0XCIpLFxuICAgICAgICBpbnZhbGlkSW5wdXQ6IG5ldyBFcnJvcihcIk1leWRhOiBJbnZhbGlkIGlucHV0LlwiKSxcbiAgICAgICAgbm9BQzogbmV3IEVycm9yKFwiTWV5ZGE6IE5vIEF1ZGlvQ29udGV4dCBzcGVjaWZpZWQuXCIpLFxuICAgICAgICBub1NvdXJjZTogbmV3IEVycm9yKFwiTWV5ZGE6IE5vIHNvdXJjZSBub2RlIHNwZWNpZmllZC5cIiksXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeVxuICAgICAqIENyZWF0ZSBhIE1leWRhQW5hbHl6ZXJcbiAgICAgKlxuICAgICAqIEEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBNZXlkYUFuYWx5emVyLCB0aGUgaW50ZXJmYWNlIGZvciB1c2luZ1xuICAgICAqIE1leWRhIGluIHRoZSBjb250ZXh0IG9mIFdlYiBBdWRpby5cbiAgICAgKlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBjb25zdCBhbmFseXplciA9IE1leWRhLmNyZWF0ZU1leWRhQW5hbHl6ZXIoe1xuICAgICAqICAgXCJhdWRpb0NvbnRleHRcIjogYXVkaW9Db250ZXh0LFxuICAgICAqICAgXCJzb3VyY2VcIjogc291cmNlLFxuICAgICAqICAgXCJidWZmZXJTaXplXCI6IDUxMixcbiAgICAgKiAgIFwiZmVhdHVyZUV4dHJhY3RvcnNcIjogW1wicm1zXCJdLFxuICAgICAqICAgXCJpbnB1dHNcIjogMixcbiAgICAgKiAgIFwiY2FsbGJhY2tcIjogZmVhdHVyZXMgPT4ge1xuICAgICAqICAgICBsZXZlbFJhbmdlRWxlbWVudC52YWx1ZSA9IGZlYXR1cmVzLnJtcztcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjcmVhdGVNZXlkYUFuYWx5emVyOiBjcmVhdGVNZXlkYUFuYWx5emVyLFxuICAgIC8qKlxuICAgICAqIExpc3QgYXZhaWxhYmxlIGF1ZGlvIGZlYXR1cmUgZXh0cmFjdG9ycy4gUmV0dXJuIGZvcm1hdCBwcm92aWRlcyB0aGUga2V5IHRvXG4gICAgICogYmUgdXNlZCBpbiBzZWxlY3RpbmcgdGhlIGV4dHJhY3RvciBpbiB0aGUgZXh0cmFjdCBtZXRob2RzXG4gICAgICovXG4gICAgbGlzdEF2YWlsYWJsZUZlYXR1cmVFeHRyYWN0b3JzOiBsaXN0QXZhaWxhYmxlRmVhdHVyZUV4dHJhY3RvcnMsXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBhbiBhdWRpbyBmZWF0dXJlIGZyb20gYSBidWZmZXJcbiAgICAgKlxuICAgICAqIFVubGVzcyBgbWV5ZGEud2luZG93aW5nRnVuY3Rpb25gIGlzIHNldCBvdGhlcndpc2UsIGBleHRyYWN0YCB3aWxsXG4gICAgICogaW50ZXJuYWxseSBhcHBseSBhIGhhbm5pbmcgd2luZG93IHRvIHRoZSBidWZmZXIgcHJpb3IgdG8gY29udmVyc2lvbiBpbnRvXG4gICAgICogdGhlIGZyZXF1ZW5jeSBkb21haW4uXG4gICAgICpcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogbWV5ZGEuYnVmZmVyU2l6ZSA9IDIwNDg7XG4gICAgICogY29uc3QgZmVhdHVyZXMgPSBtZXlkYS5leHRyYWN0KFsnemNyJywgJ3NwZWN0cmFsQ2VudHJvaWQnXSwgc2lnbmFsKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBleHRyYWN0OiBmdW5jdGlvbiAoZmVhdHVyZSwgc2lnbmFsLCBwcmV2aW91c1NpZ25hbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXNpZ25hbClcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2Vycm9ycy5pbnZhbGlkSW5wdXQ7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzaWduYWwgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2Vycm9ycy5pbnZhbGlkSW5wdXQ7XG4gICAgICAgIGVsc2UgaWYgKCFmZWF0dXJlKVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5fZXJyb3JzLmZlYXR1cmVVbmRlZjtcbiAgICAgICAgZWxzZSBpZiAoIWlzUG93ZXJPZlR3byhzaWduYWwubGVuZ3RoKSlcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2Vycm9ycy5ub3RQb3cyO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYmFya1NjYWxlID09IFwidW5kZWZpbmVkXCIgfHxcbiAgICAgICAgICAgIHRoaXMuYmFya1NjYWxlLmxlbmd0aCAhPSB0aGlzLmJ1ZmZlclNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFya1NjYWxlID0gY3JlYXRlQmFya1NjYWxlKHRoaXMuYnVmZmVyU2l6ZSwgdGhpcy5zYW1wbGVSYXRlLCB0aGlzLmJ1ZmZlclNpemUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY2FsY3VsYXRlIG1lbCBiYW5rIGlmIGJ1ZmZlciBsZW5ndGggY2hhbmdlZFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWVsRmlsdGVyQmFuayA9PSBcInVuZGVmaW5lZFwiIHx8XG4gICAgICAgICAgICB0aGlzLmJhcmtTY2FsZS5sZW5ndGggIT0gdGhpcy5idWZmZXJTaXplIHx8XG4gICAgICAgICAgICB0aGlzLm1lbEZpbHRlckJhbmsubGVuZ3RoICE9IHRoaXMubWVsQmFuZHMpIHtcbiAgICAgICAgICAgIHRoaXMubWVsRmlsdGVyQmFuayA9IGNyZWF0ZU1lbEZpbHRlckJhbmsoTWF0aC5tYXgodGhpcy5tZWxCYW5kcywgdGhpcy5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMpLCB0aGlzLnNhbXBsZVJhdGUsIHRoaXMuYnVmZmVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgY2hyb21hIGJhbmsgaWYgYnVmZmVyIGxlbmd0aCBjaGFuZ2VkXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jaHJvbWFGaWx0ZXJCYW5rID09IFwidW5kZWZpbmVkXCIgfHxcbiAgICAgICAgICAgIHRoaXMuY2hyb21hRmlsdGVyQmFuay5sZW5ndGggIT0gdGhpcy5jaHJvbWFCYW5kcykge1xuICAgICAgICAgICAgdGhpcy5jaHJvbWFGaWx0ZXJCYW5rID0gY3JlYXRlQ2hyb21hRmlsdGVyQmFuayh0aGlzLmNocm9tYUJhbmRzLCB0aGlzLnNhbXBsZVJhdGUsIHRoaXMuYnVmZmVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiYnVmZmVyXCIgaW4gc2lnbmFsICYmIHR5cGVvZiBzaWduYWwuYnVmZmVyID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vc2lnbmFsIGlzIGEgbm9ybWFsIGFycmF5LCBjb252ZXJ0IHRvIEYzMkFcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsID0gYXJyYXlUb1R5cGVkKHNpZ25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlcGFyZWRTaWduYWwgPSBwcmVwYXJlU2lnbmFsV2l0aFNwZWN0cnVtKHNpZ25hbCwgdGhpcy53aW5kb3dpbmdGdW5jdGlvbiwgdGhpcy5idWZmZXJTaXplKTtcbiAgICAgICAgdGhpcy5zaWduYWwgPSBwcmVwYXJlZFNpZ25hbC53aW5kb3dlZFNpZ25hbDtcbiAgICAgICAgdGhpcy5jb21wbGV4U3BlY3RydW0gPSBwcmVwYXJlZFNpZ25hbC5jb21wbGV4U3BlY3RydW07XG4gICAgICAgIHRoaXMuYW1wU3BlY3RydW0gPSBwcmVwYXJlZFNpZ25hbC5hbXBTcGVjdHJ1bTtcbiAgICAgICAgaWYgKHByZXZpb3VzU2lnbmFsKSB7XG4gICAgICAgICAgICB2YXIgcHJlcGFyZWRTaWduYWxfMSA9IHByZXBhcmVTaWduYWxXaXRoU3BlY3RydW0ocHJldmlvdXNTaWduYWwsIHRoaXMud2luZG93aW5nRnVuY3Rpb24sIHRoaXMuYnVmZmVyU2l6ZSk7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzU2lnbmFsID0gcHJlcGFyZWRTaWduYWxfMS53aW5kb3dlZFNpZ25hbDtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNDb21wbGV4U3BlY3RydW0gPSBwcmVwYXJlZFNpZ25hbF8xLmNvbXBsZXhTcGVjdHJ1bTtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNBbXBTcGVjdHJ1bSA9IHByZXBhcmVkU2lnbmFsXzEuYW1wU3BlY3RydW07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4dHJhY3QgPSBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZlYXR1cmVFeHRyYWN0b3JzW2ZlYXR1cmVdKHtcbiAgICAgICAgICAgICAgICBhbXBTcGVjdHJ1bTogX3RoaXMuYW1wU3BlY3RydW0sXG4gICAgICAgICAgICAgICAgY2hyb21hRmlsdGVyQmFuazogX3RoaXMuY2hyb21hRmlsdGVyQmFuayxcbiAgICAgICAgICAgICAgICBjb21wbGV4U3BlY3RydW06IF90aGlzLmNvbXBsZXhTcGVjdHJ1bSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IF90aGlzLnNpZ25hbCxcbiAgICAgICAgICAgICAgICBidWZmZXJTaXplOiBfdGhpcy5idWZmZXJTaXplLFxuICAgICAgICAgICAgICAgIHNhbXBsZVJhdGU6IF90aGlzLnNhbXBsZVJhdGUsXG4gICAgICAgICAgICAgICAgYmFya1NjYWxlOiBfdGhpcy5iYXJrU2NhbGUsXG4gICAgICAgICAgICAgICAgbWVsRmlsdGVyQmFuazogX3RoaXMubWVsRmlsdGVyQmFuayxcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NpZ25hbDogX3RoaXMucHJldmlvdXNTaWduYWwsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNBbXBTcGVjdHJ1bTogX3RoaXMucHJldmlvdXNBbXBTcGVjdHJ1bSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c0NvbXBsZXhTcGVjdHJ1bTogX3RoaXMucHJldmlvdXNDb21wbGV4U3BlY3RydW0sXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzOiBfdGhpcy5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMsXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZCYXJrQmFuZHM6IF90aGlzLm51bWJlck9mQmFya0JhbmRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgZmVhdHVyZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmUucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBhY2MsIChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBfYVtlbF0gPSBleHRyYWN0KGVsKSxcbiAgICAgICAgICAgICAgICAgICAgX2EpKTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmVhdHVyZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGV4dHJhY3QoZmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9lcnJvcnMuaW52YWxpZEZlYXR1cmVGbXQ7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbnZhciBwcmVwYXJlU2lnbmFsV2l0aFNwZWN0cnVtID0gZnVuY3Rpb24gKHNpZ25hbCwgd2luZG93aW5nRnVuY3Rpb24sIGJ1ZmZlclNpemUpIHtcbiAgICB2YXIgcHJlcGFyZWRTaWduYWwgPSB7fTtcbiAgICBpZiAodHlwZW9mIHNpZ25hbC5idWZmZXIgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvL3NpZ25hbCBpcyBhIG5vcm1hbCBhcnJheSwgY29udmVydCB0byBGMzJBXG4gICAgICAgIHByZXBhcmVkU2lnbmFsLnNpZ25hbCA9IGFycmF5VG9UeXBlZChzaWduYWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJlcGFyZWRTaWduYWwuc2lnbmFsID0gc2lnbmFsO1xuICAgIH1cbiAgICBwcmVwYXJlZFNpZ25hbC53aW5kb3dlZFNpZ25hbCA9IGFwcGx5V2luZG93KHByZXBhcmVkU2lnbmFsLnNpZ25hbCwgd2luZG93aW5nRnVuY3Rpb24pO1xuICAgIHByZXBhcmVkU2lnbmFsLmNvbXBsZXhTcGVjdHJ1bSA9IGZmdF8xLmZmdChwcmVwYXJlZFNpZ25hbC53aW5kb3dlZFNpZ25hbCk7XG4gICAgcHJlcGFyZWRTaWduYWwuYW1wU3BlY3RydW0gPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUgLyAyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlclNpemUgLyAyOyBpKyspIHtcbiAgICAgICAgcHJlcGFyZWRTaWduYWwuYW1wU3BlY3RydW1baV0gPSBNYXRoLnNxcnQoTWF0aC5wb3cocHJlcGFyZWRTaWduYWwuY29tcGxleFNwZWN0cnVtLnJlYWxbaV0sIDIpICtcbiAgICAgICAgICAgIE1hdGgucG93KHByZXBhcmVkU2lnbmFsLmNvbXBsZXhTcGVjdHJ1bS5pbWFnW2ldLCAyKSk7XG4gICAgfVxuICAgIHJldHVybiBwcmVwYXJlZFNpZ25hbDtcbn07XG4vKipcbiAqIExpc3QgYXZhaWxhYmxlIGF1ZGlvIGZlYXR1cmUgZXh0cmFjdG9ycy4gUmV0dXJuIGZvcm1hdCBwcm92aWRlcyB0aGUga2V5IHRvXG4gKiBiZSB1c2VkIGluIHNlbGVjdGluZyB0aGUgZXh0cmFjdG9yIGluIHRoZSBleHRyYWN0IG1ldGhvZHNcbiAqL1xuZnVuY3Rpb24gbGlzdEF2YWlsYWJsZUZlYXR1cmVFeHRyYWN0b3JzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmZlYXR1cmVFeHRyYWN0b3JzKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgTWV5ZGFBbmFseXplclxuICpcbiAqIEEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBNZXlkYUFuYWx5emVyLCB0aGUgaW50ZXJmYWNlIGZvciB1c2luZ1xuICogTWV5ZGEgaW4gdGhlIGNvbnRleHQgb2YgV2ViIEF1ZGlvLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGFuYWx5emVyID0gTWV5ZGEuY3JlYXRlTWV5ZGFBbmFseXplcih7XG4gKiAgIFwiYXVkaW9Db250ZXh0XCI6IGF1ZGlvQ29udGV4dCxcbiAqICAgXCJzb3VyY2VcIjogc291cmNlLFxuICogICBcImJ1ZmZlclNpemVcIjogNTEyLFxuICogICBcImZlYXR1cmVFeHRyYWN0b3JzXCI6IFtcInJtc1wiXSxcbiAqICAgXCJpbnB1dHNcIjogMixcbiAqICAgXCJjYWxsYmFja1wiOiBmZWF0dXJlcyA9PiB7XG4gKiAgICAgbGV2ZWxSYW5nZUVsZW1lbnQudmFsdWUgPSBmZWF0dXJlcy5ybXM7XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1leWRhQW5hbHl6ZXIob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTWV5ZGFBbmFseXplcihvcHRpb25zLCBPYmplY3QuYXNzaWduKHt9LCBNZXlkYSkpO1xufVxuLy8gQHRzLWlnbm9yZVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgd2luZG93Lk1leWRhID0gTWV5ZGE7XG5cbm1vZHVsZS5leHBvcnRzID0gTWV5ZGE7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/meyda/dist/node/main.js\n");

/***/ })

};
;